\documentclass[10pt,a4paper]{article}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{natbib}
%\usepackage[demo]{graphicx}

\usepackage{url}
\usepackage{fancyvrb}
\usepackage[unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=true,bookmarksopen=true,bookmarksopenlevel=2,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=false]
 {hyperref}
\hypersetup{
 pdfstartview={XYZ null null 1}}
\usepackage{breakurl}

\newcommand{\UBL}{package \texttt{UBL}\ }

\author{Paula Branco, Rita Ribeiro and Luis Torgo\\FCUP - LIAAD/INESC Tec\\University of Porto\\
  \texttt{paobranco@gmail.com}, \texttt{rpribeiro@dcc.fc.up.pt}, \texttt{ltorgo@dcc.fc.up.pt}}
\title{Utility-based Learning in R}

\begin{document}


<<setup, include=FALSE, cache=FALSE>>=
library(knitr)
## set global chunk options
opts_chunk$set(cache.path="cache/UBL-",dev="pdf",fig.path="figures/UBL-", fig.align="center", fig.show="hold",tidy=FALSE,size="footnotesize",message=FALSE)
options(replace.assign=TRUE,width=90)
##
##library(devtools)
##load_all("~/Software/R/MyPackages/UBLn")
library(uba)
library(UBL)
library(ggplot2)
library(reshape2)
library(xtable)
library(gridExtra)
library(plotrix)
library(performanceEstimation)
@
%$
\maketitle


\begin{abstract}
  
  This document describes the R \UBL package that allows the use of several methods for handling imbalanced data distributions. Imbalanced domains pose serious problems in the predictive analytics context. To deal with this problem a large number of techniques was proposed by the research community for both classification and regression tasks.
  The main goal of the R \UBL package is to facilitate the task of addressing the problem of imbalanced data distributions by providing a set of methods to deal with this problem. 
   
\end{abstract}

% ====================================================================
\section{Introduction}

The goal of this document is to describe the methods available in package \UBL to deal with imbalanced domains. \texttt{UBL} package aims at providing a diverse set of methods to address predictive tasks under imbalanced data distributions. The package provides tools suitable for both classification and regression tasks.
All the methods were extended for being able to deal with multiclass problems and with regression problems which may possibly contain several relevant bumps across the domain of the target variable.

The problem of imbalanced domains is related to conjunction of two aspects: i) an asymmetric distribution of the examples over the target variable domain, and ii) a user preference bias towards the rare cases. In this context, the least represented ranges/classes of the target variable are also the most important to the user. However, being cases poorly represented, the learning algorithms will have difficulty in focusing on these cases. The algorithms will tend to present a good performance on the normal and frequent cases and will display a worst performance on the most relevant and scarce cases.


The methods implemented in \UBL are pre-processing approaches which aim at altering the original data set to match the user preferences. This means that the methods for dealing with imbalanced domains are only relevant when the user preferences are focused on the least represented examples. In fact, if the most frequent cases are the most important, then the learning algorithms will naturally tend to focus on these examples, and therefore there is no need to change the original distribution. On the other hand, when the most relevant examples are scarcely represented any learning algorithm used will focus on the normal cases and will fail the most important predictions on the rare examples.

Several types of approaches exist for handling imbalanced domains. Some approaches act as a \textbf{pre-processing} step by manipulating the examples distribution to match the user preferences. Other methods \textbf{change the learning algorithms} for dealing with a specific imbalanced task. There are also strategies that are applied as a \textbf{post-processing} step and change the predictions made by a standard learner using the original data set.


In \UBL we have focused on pre-processing strategies to address the problem of imbalanced distributions. These strategies change the original distribution of examples by removing or/and adding examples, i.e., by performing under-sampling or over-sampling. The under-sampling strategies may be random or focused. By focused under-sampling we mean that the discarded examples satisfy a given requirement, such as: are possibly noisy examples, are too distant from the decision border, are too close to the border, etc. Regarding the over-sampling methods there are two main options: over-sampling is accomplished by the introduction of replicas of examples or by the generation of new synthetic examples. For the strategies which include copies of existing examples the cases may be selected randomly or in an informed fashion. Approaches that build synthetic cases differ among themselves in the generation process adopted. Several strategies combine under-sampling and over-sampling methods in different ranges/classes of the target variable.



% ====================================================================
\section{Package Installation Guidelines}

The \UBL has two releases which can be installed: the stable and the development. To install the latest stable release (from github) do the following in R:

<<message=FALSE, eval=FALSE>>=    
library(devtools)  # You need to install this package!
install_github("ltorgo/UBL",ref="master") # to install the stable release
@

If you want to install the development release you need to do the following in R:

<<message=FALSE, eval=FALSE>>=
library(devtools)  # You need to install this package!
install_github("ltorgo/UBL",ref="develop") # to install the development release
@


If somehow the previous instructions fail (there are reports of problems with different libcurl library version on Linux hosts) you may try as an alternative the following in R:
<<message=FALSE, eval=FALSE >>=
library(devtools)
# to install the development release
install_git("https://github.com/ltorgo/UBL",branch="develop")
# to install the stable release
install_git("https://github.com/ltorgo/UBL",branch="master")
@

After installation using any of the above procedures, the package can be used as any other R package by doing:

<<>>=
library(UBL)
@

Further help and illustrations can be obtained through the many help pages of each function defined in the package that contain lots of illustrative examples. Again, these help pages can be accessed as any other R package, through R help system (e.g. running \texttt{help.start()} at R command line).

% ====================================================================
\section{A Simple Illustrative Example}

We will start with a classification task with 3 classes. 
<<iris_data>>=
library(UBL)  # Loading our infra-structure
library(e1071) # packge containing the svm we will use
data(iris)                      # The data set we are going to use
# transforming into a multiclass imbalanced problem
data <- iris[-c(91:125), c(1, 2, 5)] 
table(data$Species) 
@ 


If we now train a svm in this data, we obtain the following:

<<iris_svm_unbalanced>>=
set.seed(123)
samp <- sample(1:nrow(data), nrow(data)*0.7)
train <- data[samp,]
test <- data[-samp,]

model <- svm(Species~., train)
preds <- predict(model,test)
table(preds, test$Species) # confusion matrix
@

Clearly, the model presents a poor performance on least represented class, the \Sexpr{names(which(table(test[,3])==min(table(test[,3]))))} class. However, for the most common class, the \Sexpr{names(which(table(test[,3])==max(table(test[,3]))))} the learner always predicts correctly.

Now, we can try to apply a strategy for dealing with imbalanced domains, and check again the models performance. 
<<iris_svm_unbalanced2>>=
# change the examples in train by apllying the smote strategy
newtrain <- smoteClassif(Species~., train, C.perc="balance")

# generate a new model with the changed data
newmodel <- svm(Species~., newtrain)
preds <- predict(newmodel,test)
table(preds, test$Species)

@

We can observe that the least represented class, virginica, now presents an improved result.
If the previous model was unable to correctly classify any examples with class label of virginica, now there are three virginica cases which have a correct prediction!


We can also try a simple random under-sampling method:

<<iris_svm_unbalanced3>>=
# apply random under-sampling strategy
newtrain2 <- randOverClassif(Species~., train, C.perc="balance")

#generate a new model with the modified data set
newmodel2 <- svm(Species~., newtrain2)
preds <- predict(newmodel2, test)
table(preds, test$Species)

@

% ====================================================================
\section{Methods for Addressing Classification Tasks under Imbalanced Domains}


\subsection{Random Under-sampling}\label{sec:RUClassif}

The random under-sampling strategy is among the simplest strategies for dealing with the class imbalanced problem. To force the learners to focus on the most important and least represented class(es) this technique randomly removes examples from the most represented and less important classes. This process allows to obtain a more balanced data set, although some important data may have been discarded with this technique. Another side effect of this strategy is a big reduction on the number of examples in the data set which facilitates the learners task although some important data may be ignored.

This strategy is implemented in \UBL taking into consideration the possible existence of several minority classes. The user may define through \texttt{C.perc} parameter which are the normal and less important classes and the under-sampling percentages to apply in each one of them. Another possibility is to select \texttt{"balance"} or \texttt{"extreme"} for the parameter \texttt{C.perc}. These two options automatically estimate the classes and under-sampling percentages to apply. The \texttt{"balance"} option obtains a balanced number of examples in all the existing classes, and the \texttt{"extreme"} option inverts the existing frequencies, transforming the most frequent classes into the less frequent and vice-versa. The following examples shows how these options can be used and their impact:

<<iris_ru>>=
library(UBL)  # Loading our infra-structure
library(e1071) # packge containing the svm we will use
data(iris)                      # The data set we are going to use
# transforming into a multiclass imbalanced problem
data <- iris[-c(91:125), c(1, 2, 5)] 
# check the unbalanced data
table(data$Species)

## now, using random under-sampling to create a more 
## "balanced problem" automatically

newData <- randUnderClassif(Species ~ ., data)
table(newData$Species)
@

Figure \ref{fig:Iris_RU1} shows the impact of this strategy in the examples distribution.


<<Iris_RU1,fig.cap="The impact of random under-sampling strategy.",out.width="0.8\\textwidth", echo=FALSE>>=
  par(mfrow = c(1, 2))
  plot(data[, 1], data[, 2], pch = as.integer(data[, 3]), col=as.integer(data[,3]),
       main = "Original Data")
  plot(newData[, 1], newData[, 2], pch = as.integer(newData[,3]), col=as.integer(newData[,3]),
       main = "Under-sampled Data")
@ 

Another example with iris data:

<<another_iris_exRU>>=
  RUmy.ir <- randUnderClassif(Species~., data, list(setosa=0.3, versicolor=0.7))
  RUB.ir <- randUnderClassif(Species~., data, "balance")
  RUE.ir <- randUnderClassif(Species~., data, "extreme")

@


<<RU_tab, echo=FALSE, results='asis'>>=
nm <- c("Original","RUmy.ir", "RUB.ir","RUE.ir")

res <- c(table(data$Species),table(RUmy.ir$Species), table(RUB.ir$Species), table(RUE.ir$Species))

m <- matrix(res, nrow=4,ncol=3, byrow=TRUE, dimnames=list(nm, names(table(data$Species))))

xt <-xtable(m, caption="Number of examples in each class for different parameters of random under-sampling strategy.",label="tab:RU_tab")
print(xt,comment = FALSE, type = 'latex')

@

The impact of the strategies on the number of examples in each class of the data set are in Figure\ref{fig:Iris_RU2}.



<<Iris_RU2, fig.cap="Random Under-sampling strategy for different parameters values.", echo=FALSE>>=
DF <- rbind(data.frame(Dat="Original",obs=data$Species), data.frame(Dat="RUmy.ir", obs=RUmy.ir$Species), data.frame(Dat="RUB.ir", obs=RUB.ir$Species), data.frame(Dat="RUE.ir", obs=RUE.ir$Species))
g1 <- ggplot(DF,aes(x=obs, fill=Dat, colour=Dat))+geom_histogram(binwidth=1, position="dodge", aes(group=Dat), colour="black")

g2 <- ggplot(DF,aes(x=Dat, fill=obs, colour=obs))+geom_histogram(binwidth=1, position="fill", aes(group=obs), colour="black")

plots <- list(g1, g2)

do.call(grid.arrange, plots)
@



\subsection{Random Oversampling}\label{sec:ROClassif}

The random over-sampling strategy introduces replicas of already existing examples in the data set. The replicas to include are randomly selected among the least populated classes. This allows to obtain a better balanced data set without discarding any examples. However, this method has a strong impact on the number of examples of the new data set which can represent a difficulty to the used learner.

This strategy is implemented in \UBL taking into consideration the possible existence of several minority classes. The user may define through \texttt{C.perc} parameter which are the most important classes and their respective over-sampling percentages. The parameter \texttt{C.perc} may also be set to \texttt{"balance"} or \texttt{"extreme"}. These two options automatically estimate the classes and over-sampling percentages to apply. Similarly to the previous strategy the \texttt{"balance"} option allows to obtain a balanced number of examples in all the existing classes, and the \texttt{"extreme"} option inverts the existing frequencies, transforming the most frequent classes into the less frequent and vice-versa. The following examples show how these options can be used and their impact:

<<iris_RO>>=
## now using random over-sampling to create a 
## data with more 600% of examples in the 
## virginica class
RO.U1<- randOverClassif(Species ~ ., data, 
                        C.perc=list(virginica=5))
RO.U2<- randOverClassif(Species ~ ., data, 
                        C.perc=list(versicolor=4, virginica=2.5))
RO.B <- randOverClassif(Species ~ ., data, C.perc="balance")
RO.E <- randOverClassif(Species ~ ., data, C.perc="extreme")
@



<<RO_tab, echo=FALSE, results='asis'>>=

nm <- c("Original","RO.U1", "RO.U2", "RO.B","RO.E")

res <- c(table(data$Species),table(RO.U1$Species), table(RO.U2$Species), table(RO.B$Species), table(RO.E$Species))

m <- matrix(res, nrow=5,ncol=3, byrow=TRUE, dimnames=list(nm, names(table(data$Species))))


xt <-xtable(m, caption="Number of examples in each class for different Random over-sampling parameters.",label="tab:RO_tab")
print(xt,comment = FALSE, type = 'latex')

@
Figure \ref{fig:IrisRO} shows the impact of this strategy in the examples distribution. We have introduced a small perturbation on the examples position to be more clear the replicas that were introduced.

<<IrisRO,fig.cap="The impact of random over-sampling Strategy.",out.width="0.8\\textwidth", echo=FALSE>>=
  par(mfrow = c(2, 2))
  plot(data[, 1], data[, 2], pch =as.integer(data[, 3]), col=as.integer(data[,3]),
       main = "Original Data")
  plot(jitter(RO.U1[, 1]), jitter(RO.U1[, 2]), pch=as.integer(RO.U1[,3]), col=as.integer(RO.U1[,3]),
       main = "over-sampled Data with user defined parameter")
  plot(jitter(RO.B[, 1]), jitter(RO.B[, 2]), pch=as.integer(RO.B[,3]), col=as.integer(RO.B[,3]),
       main = "over-sampled Data with balance parameter")
  plot(jitter(RO.E[, 1]), jitter(RO.E[, 2]), pch=as.integer(RO.E[,3]), col=as.integer(RO.E[,3]),
       main = "over-sampled Data with extreme parameter")
@ 



Figure \ref{fig:Iris_RO2} shows the impact of this strategy on the number of examples in the data set.

<<Iris_RO2, fig.cap="Impact of Random over-sampling strategy for different parameters values.", echo=FALSE>>=
DF <- rbind(data.frame(Dat="Original",obs=data$Species), data.frame(Dat="RO.U1", obs=RO.U1$Species), data.frame(Dat="RO.B", obs=RO.B$Species), data.frame(Dat="RO.E", obs=RO.E$Species))
g1 <- ggplot(DF,aes(x=obs, fill=Dat, colour=Dat))+geom_histogram(binwidth=1, position="dodge", aes(group=Dat), colour="black")

g2 <- ggplot(DF,aes(x=Dat, fill=obs, colour=obs))+geom_histogram(binwidth=1, position="fill", aes(group=obs), colour="black")

plots <- list(g1, g2)

do.call(grid.arrange, plots)
@


\subsection{Tomek Links}\label{sec:Tomek}

Tomek Links \cite{tomek1976two} can be defined as follows: two examples form a Tomek Link if and only if they belong to different classes and are each other nearest neighbors. This is a property existing between a pair of examples $(S_i, S_j)$ having different class labels and for which 

$\nexists S_k : dist(S_i,S_k) < dist(S_i,S_j) \vee dist(S_j, S_k)<dist(S_i,S_j)$

\noindent Having determined the examples which form Tomek Links, these connections may be explained because either the examples are both borderline examples or one of the examples may be considered as noise.
Therefore, there are two possibilities of using Tomek links to accomplish under-sampling:
\begin{itemize}
  \item remove the two examples forming a Tomek link, or
  \item only remove the example from the most populated class which forms a Tomek link.
\end{itemize}

These two options correspond to using Tomek link as cleaning technique (by removing both borderline examples) or as an under-sampling method for balancing the classes (by removing the majority class example).


In \UBL we have adapted this technique for being able to deal with multiclass imbalanced problems. 
For working with more than two classes some issues were considered: 
\begin{itemize}
\item allow the user to select which classes should be under-sampled (if not defined, the default is to under-sample all the existing classes);
\item if the user selects a given number of classes what to do to break the link, i.e., how to decide which example(s) to remove (if any). 
\end{itemize}
So, in \UBL the user may chose for which classes he is interested in removing examples through the \texttt{Cl} parameter. Moreover, the user can also decide if both examples are removed or if just one is discarded using the \texttt{rem} parameter. If this can be easily understood in two class problems, the impact of these parameters may no be so clear for multiclass imbalanced tasks. 
In fact,the options set for \texttt{Cl} and \texttt{rem} parameters may "disagree". In those cases, the preference is given to the \texttt{Cl} options once the user choose that specific set of classes to under-sample and not the other ones (even if the defined classes are not the larger ones). This means that, when making a decision on how many and which examples will be removed the first criteria used will be the \texttt{Cl} definition.


For a better clarification of the behavior stated we now provide some possible scenarios for multiclass problems and the corresponding expected behavior:

\begin{itemize}
\item \texttt{Cl} is set to one class which is neither the more nor the less frequent, and \texttt{rem} is set to "maj". The expected behavior is the following:
- if a Tomek link exists connecting the largest class and another class(not included in \texttt{Cl}): no example is removed;
- if a Tomek link exists connecting the larger class and the class defined in \texttt{Cl}: the example from the \texttt{Cl} class is removed (because the user expressly indicates that only examples from class \texttt{Cl} should be removed);

\item \texttt{Cl} includes two classes and \texttt{rem} is set to "both". This function will do the following:
- if a Tomek link exists between an example with class in \texttt{Cl} and another example with class not in \texttt{Cl}, then, only the example with class in \texttt{Cl} is removed;
- if the Tomek link exists between two examples with classes in \texttt{Cl}, then, both are removed.

\item \texttt{Cl} includes two classes and \texttt{rem} is set to "maj". The behavior of this function is the following:
-if a Tomek link exists connecting two classes included in \texttt{Cl}, then only the example belonging to the more populated class is removed;
-if a Tomek link exists connecting an example from a class included in \texttt{Cl} and another example whose class is not in \texttt{Cl} and is the largest class, then, no example is removed.

\end{itemize}


We must also highlight that this strategy strongly depends on the distance metric considered for the nearest neighbors computation. We provide in \UBL several different distance measures which are able to deal with numeric and/or nominal features, such as Manhattan distance, Euclidean Distance, HEOM or HVDM. For more details on the available distance functions check Section \ref{sec:distFunc}. The user may set the desired distance metric through the \texttt{dist} parameter.


The implementation provided in this package returns a list containing: the new data set modified through the Tomek links strategy and the indexes of the examples removed. Under certain situations, this strategy is not able to remove any example of the data set. In this case, a warning is issued to advert the user that no example was removed.

The following examples with iris data set shows how Tomek links can be applied.


<<iris_TL>>=
# using the default in all parameters
  ir <- TomekClassif(Species~., data)
# using chebyshev distance metric, and selecting only two classes to under-sample
  irCheb <- TomekClassif(Species~., data, dist="Chebyshev", 
                         Cl=c("virginica", "setosa"))
# using Manhattan distance, enable the removal of examples from all classes, and
# select to break the link by only removing the example from the majority class
  irManM <- TomekClassif(Species~., data, dist="Manhattan", Cl="all", rem="maj") 
  irManB <- TomekClassif(Species~., data, dist="Manhattan", Cl="all", rem="both")

# check the new irCheb data set
summary(irCheb[[1]])

# check the indexes of the examples removed:
irCheb[[2]]
@

<<TL_table, echo=FALSE, results='asis'>>=

nm <- c("Original","ir", "irCheb", "irManM","irManB")

res <- c(table(data$Species),table(ir[[1]]$Species), table(irCheb[[1]]$Species), table(irManM[[1]]$Species), table(irManB[[1]]$Species))

m <- matrix(res, nrow=5,ncol=3, byrow=TRUE, dimnames=list(nm, names(table(data$Species))))

xt <-xtable(m, caption="Number of examples in each class for different Tomek Links parameters.",label="tab:TL_table")
print(xt,comment = FALSE, type = 'latex')

@


Figure \ref{fig:TL_difPar} shows the impact on the virginica and versicolor classes of the last experiences.
<<TL_difPar, fig.cap="Impact of Tomek links strategy in versicolor and virginica classes.", echo=FALSE>>=
# visualizing the two classes that have changed (virginica and versicolor)
dO <- subset(data, Species!="setosa")
dC <- subset(irCheb[[1]], Species!="setosa")
dM <- subset(irManM[[1]], Species!="setosa")
dB <- subset(irManB[[1]], Species!="setosa")

par(mfrow = c(2, 2))
plot(dO[,1], dO[,2], col=as.integer(dO[,3]), main="original data")
plot(dC[,1], dC[,2], col=as.integer(dC[,3]), main="Tomek links with Chebyshev distance")
plot(dM[,1], dM[,2], col=as.integer(dM[,3]), main="Tomek links removing majority class")
plot(dB[,1], dB[,2], col=as.integer(dB[,3]), main="Tomek links removing both examples")

@



\subsection{Condensed Nearest Neighbors}\label{sec:CNN}

The Condensed nearest neighbors rule (CNN) was presented by \cite{cnn}. The goal of this strategy is to perform under-sampling by building a subset of examples which is consistent with the original data. A subset is consistent with another if the elements in the subset classify correctly all the original examples using a 1-NN. 

To build a consistent subset we have adapted the proposal of \cite{KM97} to multiclass problems. The user starts by defining which are the most relevant classes in the data set using the \texttt{Cl} parameter. If the user prefers, an automatic option that corresponds to setting \texttt{Cl} to "smaller", evaluates the distribution of the classes and determines which classes are candidates for being the smaller and most important. By default, this parameter is set to "smaller" which means that the most relevant classes are automatically estimated from the data and correspond to those classes containing less than $\frac{number of examples}{number of classes}$ examples. For instance, if a data set has 5 classes and a total number of examples of 100, the classes with less than 20 $(\frac{100}{5})$ examples will be considered the most important. The examples of the most relevant classes are then joined with one randomly selected example from each of the other classes. A 1-NN is computed with the distance metric provided by the user through the \texttt{dist} parameter. Then, all the examples from the original data set which were mislabeled in this procedure are also added to the reduced data set. This allows to obtain a smaller data set by removing examples from the larger and less important classes which are farther from the decision border.

This strategy is available through the \texttt{CNNClassif} function. This function returns a list containing: the modified data set, the classes that were considered important, and finally the unimportant classes.


We can now see some examples of this approach to the modified iris data.

<<Iris_CNN>>=
set.seed(123)
  myCNN <- CNNClassif(Species~., data, Cl=c("setosa", "virginica"))
  CNN1 <- CNNClassif(Species~., data, Cl="smaller")
  CNN2 <- CNNClassif(Species~., data, Cl="versicolor")
  CNN3 <- CNNClassif(Species~., data, dist="Chebyshev", Cl="virginica")

# check the new data set obtained in CNN1
summary(CNN1[[1]]$Species)

# check the classes which were considered important
CNN1[[2]]

# check the classes which were considered unimportant
CNN1[[3]]

@


<<CNN_table, echo=FALSE, results='asis'>>=

nm <- c("Original","myCNN", "CNN1", "CNN2","CNN3")

res <- c(table(data$Species),table(myCNN[[1]]$Species), table(CNN1[[1]]$Species), table(CNN2[[1]]$Species), table(CNN3[[1]]$Species))

m <- matrix(res, nrow=5,ncol=3, byrow=TRUE, dimnames=list(nm, names(table(data$Species))))


xt <-xtable(m, caption="Number of examples in each class for different CNN parameters.",label="tab:CNN_table")
print(xt,comment = FALSE, type = 'latex')


@



It is clear from these examples that this method entails a significant reduction on the number of examples left in the modified data set. Moreover, since there is a random selection of points belonging to the less important class(es) the obtained data set may differ for different runs. Figure \ref{fig:CNN_plot} provides a visual illustration of the impact of this method.

<<CNN_plot, echo=FALSE, fig.cap="Impact of CNN method for different values of parameter Cl.">>=
par(mfrow=c(2,2))
plot(data[,1], data[,2], col=as.integer(data[,3]), main="original data")
plot(myCNN[[1]][,1], myCNN[[1]][,2], col=as.integer(myCNN[[1]][,3]), main="setosa and virginica are the  important classes")
plot(CNN1[[1]][,1], CNN1[[1]][,2], col=as.integer(CNN1[[1]][,3]), main="Smaller classes automatically estimated")
plot(CNN2[[1]][,1], CNN2[[1]][,2], col=as.integer(CNN2[[1]][,3]), main="versicolor is the most important class")
@


\subsection{One-sided Selection}\label{sec:OSS}


\cite{KM97} proposed a new method for modifying a given data set by applying the Tomek links under-sampling strategy and afterwards the CNN technique. \cite{batista2004study} also tested the reverse order for applying the techniques: first apply CNN method and then Tomek links. The main motivation for this was to apply Tomek links to an already reduced data set because Tomek links technique is a more computationally demanding task.

In \UBL we have gathered under the same function, \texttt{OSSClassif}, both techniques. To distinguish between the two methods, we included a parameter \texttt{start} which defaults to CNN. The user may therefore select the order in which we want to apply the two techniques: CNN and Tomek links. In this implementation, when Tomek links are applied, they always imply the removal of both examples forming the Tomek link. 

We have adapted both methods for dealing with multiclass imbalanced problems. To do so, we have included the parameter \texttt{Cl} which allows the user to specify the most important classes. Similarly to the behavior of CNN strategy, the user may define for the \texttt{Cl} parameter the value "smaller". In this case, the most important classes are automatically determined using the same method presented in CNN strategy. When the relevant classes are chosen with this automatic method, the less frequent classes (which are considered the most relevant ones) are those which have a frequency below $\frac{number of examples}{number of classes}$. This means that all the classes with a frequency below the mean frequency of the data set classes is considered a minority class. The \texttt{OSSClassif} function also allows to specify which distance metric should be used in the neighbors computation. For more details on the available distance functions see Section \ref{sec:distFunc}. We must also mention that this strategy may potentially produce warnings due to the use of Tomek links strategy. As previously mentioned when Tomek links approach was presented, this method may not change the provided data set. Iin this case a warning is issued to advert the user. This warning may also occur when using OSS strategy if the Tomek links method produce it.


<<Iris_OSS>>=
set.seed(1234)

ir2 <- OSSClassif(Species~., data, dist="p-norm", p=3, Cl="virginica")
ir3 <- OSSClassif(Species~., data, Cl=c("versicolor", "virginica"), start="Tomek")
ir4 <- OSSClassif(Species~., data)

summary(ir2$Species)
summary(ir3$Species)
summary(ir4$Species)

@



<<oss_table, echo=FALSE, results='asis'>>=
nm <- c("Original","ir2", "ir3","ir4")

res <- c(table(data$Species),table(ir2$Species), table(ir3$Species), table(ir4$Species))

m <- matrix(res, nrow=4, ncol=3, byrow=TRUE, dimnames=list(nm, names(table(data$Species))))

xt <-xtable(m, caption="Number of examples in each class for different OSS parameters.",label="tab:oss_table")
print(xt,comment = FALSE, type = 'latex')

@

The impact of these methods on the number of examples in each class are in Table \ref{tab:oss_table}. The distribution of the results obtained with these methods can be visualized in Figure \ref{fig:OSS_plot}.


<<OSS_plot, fig.cap="OSS techniques applied to a multiclass imbalanced problem.", echo=FALSE>>=
par(mfrow=c(2,2))
plot(data[,1], data[,2], col=as.integer(data[,3]), main="original data")
plot(ir2[,1], ir2[,2], col=as.integer(ir2[,3]), main="virginica is the most important class")
plot(ir3[,1], ir3[,2], col=as.integer(ir3[,3]), main="versicolor and virginica are the important classes. First apply Tomek links")
plot(ir4[,1], ir4[,2], col=as.integer(ir4[,3]), main="default values applied")
@





\subsection{Edited Nearest Neighbors}\label{sec:ENN}

The Edited Nearest Neighbor (ENN) algorithm was proposed by \cite{wilson1972asymptotic}. This method falls within the under-sampling approaches and has been used to address imbalanced classification problems. The original ENN algorithm uses a 3-NN classifier to remove the examples whose class is different from the class of at least two of its neighbors. 

We have implemented this approach for being able to tackle multiclass problems, allowing the user to specify through the \texttt{Cl} parameter a subset of classes which should be under-sampled. Moreover, in our implementation, the user may also define the number of nearest neighbors that should be considered by the algorithm. This means that an example is removed if its class label is different from the class label of at least half of its k-nearest neighbors and if it belongs to the subset of classes candidates for removal. The ENN algorithm is available in \UBL through the function\texttt{ENNClassif}. The number of neighbors to consider is set through the parameter \texttt{k} and the subset of classes that are candidates for being under-sampled are defined through the \texttt{Cl} parameter. The default of \texttt{Cl} is "all", meaning that all classes are candidates for having examples removed. The user can also specify which distance metric he wants to use in the nearest neighbors computation. The function \texttt{ENNClassif} returns a list containing the new under-sampled data set and the indexes of the examples removed.

It is possible that ENN find no examples to remove, which means that, for the parameters selected, teher are no examples satisfying the necessary conditions to be removed. In this case, a warning is issued with the goal or adveting the user that the satrtey is not modifying the data set provided.


<<Iris_ENN>>=
  set.seed(123)
  Man5 <- ENNClassif(Species~., data, k=5, dist="Manhattan", Cl="all") 
  Default <- ENNClassif(Species~., data)
  ChebSub7 <- ENNClassif(Species~., data, k=7, dist="Chebyshev", 
                         Cl=c("virginica", "setosa"))
  ChebAll7 <- ENNClassif(Species~., data, k=7, dist="Chebyshev")
  HVDM3 <- ENNClassif(Species~., data, k=3, dist="HVDM")
@

In Table \ref{tab:iris_ENN_table} we can observe the examples distributions for some parameters settings in ENN strategy and in Figure \ref{fig:ir_ENN_plot} we can visualize that distribution.

<<iris_ENN_table, results='asis', echo=FALSE>>=
nm <- c("Original","Man5", "Default","ChebSub7", "ChebAll7", "HVDM3")

res <- c(table(data$Species),table(Man5[[1]]$Species), table(Default[[1]]$Species), table(ChebSub7[[1]]$Species), table(ChebAll7[[1]]$Species), table(HVDM3[[1]]$Species))

m <- matrix(res, nrow=6,ncol=3, byrow=TRUE, dimnames=list(nm, names(table(Man5[[1]]$Species))))

xt <-xtable(m, caption="Number of examples in each class for different parameters of ENN strategy.",label="tab:iris_ENN_table")
print(xt,comment = FALSE, type = 'latex')
@


<<ir_ENN_plot, echo=FALSE, fig.cap="Impact in the Original data set of several parameters for ENN strategy",out.height="0.5\\textheight">>=
DF <- rbind(data.frame(Dat="Original",obs=as.factor(data$Species)), data.frame(Dat="Manhattan5NN", obs=as.factor(Man5[[1]]$Species)), data.frame(Dat="Default", obs=as.factor(Default[[1]]$Species)), data.frame(Dat="Chebyshev7NNSub", obs=as.factor(ChebSub7[[1]]$Species)), data.frame(Dat="Chebyshev7NNAll", obs=as.factor(ChebAll7[[1]]$Species)), data.frame(Dat="HVDM3", obs=as.factor(HVDM3[[1]]$Species)))

g1 <- ggplot(DF,aes(x=obs, fill=Dat, colour=Dat))+geom_histogram(binwidth=1, position="dodge", aes(group=Dat), colour="black")


g2 <- ggplot(DF,aes(x=Dat, fill=obs, colour=obs))+geom_histogram(binwidth=1, position="fill", aes(group=obs), colour="black")+theme(axis.text.x  = element_text(angle=90, vjust=0.5))

plots <- list(g1, g2)

do.call(grid.arrange, plots)

@


This strategy has an unexpected behavior at first sight. In fact, the ENN method has further reduced the already minority classes. This can be explained by the goal of the ENN method which, being a cleaning technique, discards examples which may introduce errors no mater to which class they belong. As we know, in the iris data set the classes versicolor and virginica are the ones which are more difficult to classify. Therefore, the applied ENN  strategy will try to remove examples exactly from those two classes.

Another example with a different data set is shown next using the data set \texttt{cats} from package \texttt{MASS}.


<<ENN_cats>>=
library(MASS)
data(cats)
# check the data set
summary(cats$Sex)

# Change the data set using ENN strategy
newdata1 <- ENNClassif(Sex~., cats)
newdata2 <- ENNClassif(Sex~., cats, Cl="M")
# check the number of examples in each class
summary(newdata1[[1]]$Sex)
summary(newdata2[[1]]$Sex)

# check visually the examples distribution
g <-ggplot(cats, aes(Bwt, Hwt, col=Sex))+geom_point()+ggtitle("Original data set")

# check visually the impact of the strategies
g1 <-ggplot(newdata1[[1]], aes(Bwt, Hwt, col=Sex))+
     geom_point()+ggtitle("First modified data set")
g2 <-ggplot(newdata2[[1]], aes(Bwt, Hwt, col=Sex))+
     geom_point()+ggtitle("Second modified data set")

do.call(grid.arrange, list(g,g1,g2))

@

Sometimes, this method is not capable of removing any example. When this happens, the original data set remains unchanged and an warning is issued. On the other hand, with some data sets, this algorithm may completely remove one or more classes. This behavior may jeopardize the use of standard learning algorithms because they are provided with data set with only one class in the target variable. To overcome this issue, when a class is completely removed with the ENN strategy we randomly chose one example of that class to add to the under-sampled data set.


\subsection{Neighborhood Cleaning Rule}\label{sec:NCL}

The Neighborhood Cleaning Rule (NCL) algorithm was proposed in \cite{laurikkala2001improving}. This approach starts by splitting the data set $D$ in two: a subset $C$ with the examples belonging to the most important (an usually less frequent) class(es) and another subset $O$ containing the examples from the less important class(es). A new set $A_1$ of examples is formed with the noisy examples belonging to the subset $O$ which are identified using the ENN method.
Then, another set $A_2$ of examples is built as follows. For each class $C_i$ in $O$, the k nearest neighbors of each example in $C_i$ are scanned. The example is included in $A_2$ if all the scanned k nearest neighbors have a class label not contained in $C$ and if the example belongs to a class which has a cardinal of at least $\frac{1}{2}$ of the cardinal of smaller class in $C$. This last constraint forces the algorithm to keep the examples of classes with to few examples.
Finally, the examples in $A_1$ and $A_2$ are removed from the original data set.

Since this strategy internally uses the ENN approach we highlight that it is possible that warnings are issued. As mentioned before, the user is always adverted if ENN does not alter the data set. This can also happen with NCL if internally the ENN does not remove any example.

The NCL approach is available in \UBL through the \texttt{NCLClassif} function. In addition to providing a formula describing the prediction problem (\texttt{form}) and a data set (\texttt{data}) the user may set the parameters corresponding to the number of neighbors considered (\texttt{k}), the distance function used (\texttt{dist}) and the classes that should be under-sampled (\texttt{Cl}). This last parameter may be set to \texttt{smaller}. In this case, the smaller classes are automatically estimated, and assumed to be the most important ones. All the other least important classes are candidates for the under-sampling of NCL method to be applied. We now provide some examples of application of the NCL method. Table \ref{tab:iris_NCL_table} provides the number of examples in each class for different parameters of NCL method and in Figure \ref{fig:NCL_plot} the changes produced by the use of this method may be visualized.

<<Iris_NCL>>=
set.seed(1234)
ir.M1 <- NCLClassif(Species~., data, k=3, dist="p-norm", p=1, Cl="smaller")
ir.M2<- NCLClassif(Species~., data, k=1, dist="p-norm", p=1, Cl="smaller")
ir.Def <- NCLClassif(Species~., data)
ir.Ch <- NCLClassif(Species~., data, k=7, dist="Chebyshev", Cl="virginica")
ir.Eu <- NCLClassif(Species~., data, k=3, dist="Euclidean", 
                    Cl=c("setosa", "virginica"))
@


<<iris_NCL_table, results='asis', echo=FALSE>>=
nm <- c("Original","ir.M1", "ir.M2","ir.Def", "ir.Ch", "ir.Eu")

res <- c(table(data$Species),table(ir.M1$Species), table(ir.M2$Species), table(ir.Def$Species), table(ir.Ch$Species), table(ir.Eu$Species))

m <- matrix(res, nrow=6, ncol=3, byrow=TRUE, dimnames=list(nm, names(table(Man5[[1]]$Species))))

xt <-xtable(m, caption="Number of examples in each class for different parameters of NCL strategy.",label="tab:iris_NCL_table")
print(xt,comment = FALSE, type = 'latex')
@


<<NCL_plot,fig.cap="NCL techniques applied to a multiclass imbalanced problem.", echo=FALSE>>=
g1 <- ggplot(data, aes(x=data[,1], y=data[,2],color=data[,3]))+xlab("Length")+ylab("Width")+geom_point()+ggtitle("Original data")+scale_color_discrete(name="Species")
g2 <- ggplot(ir.M1, aes(x=ir.M1[,1], y=ir.M1[,2],color=ir.M1[,3]))+xlab("Length")+ylab("Width")+geom_point()+ggtitle("Manhattan distance and 3-NN")+scale_color_discrete(name="Species")
g3 <- ggplot(ir.M2, aes(x=ir.M2[,1], y=ir.M2[,2],color=ir.M2[,3]))+xlab("Length")+ylab("Width")+geom_point()+ggtitle("Manhattan distance and 1-NN")+scale_color_discrete(name="Species")
g4 <- ggplot(ir.Def, aes(x=ir.Def[,1], y=ir.Def[,2],color=ir.Def[,3]))+xlab("Length")+ylab("Width")+geom_point()+ggtitle("Default values")+scale_color_discrete(name="Species")
g5 <- ggplot(ir.Ch, aes(x=ir.Ch[,1], y=ir.Ch[,2],color=ir.Ch[,3]))+xlab("Length")+ylab("Width")+geom_point()+ggtitle("Chebyshev dist., 7-NN")+scale_color_discrete(name="Species")
g6 <- ggplot(ir.Eu, aes(x=ir.Eu[,1], y=ir.Eu[,2],color=ir.Eu[,3]))+xlab("Length")+ylab("Width")+geom_point()+ggtitle("Euclidean distance, 3-NN")+scale_color_discrete(name="Species")

plots <- list(g1, g2, g3, g4, g5, g6)

do.call(grid.arrange, plots)
@

\subsection{Generation of synthetic examples by the introduction of Gaussian Noise}\label{sec:gnClassif}

The use of Gaussian Noise to introduce a small perturbation in the data set examples was proposed by \cite{lee1999regularization} and then extended in \cite{lee2000noisy}. The proposed method consisted of producing replicas of the examples of the minority class by introducing normally distributed noise. In this approach, the majority class remained unchanged while the minority class was increased. The noise introduced depends on a fraction of the standard deviation of each numeric feature.



We have adapted this technique to multiclass imbalanced problems. Moreover, we have also included the possibility of combining this over-sampling procedure with the random under-sampling technique described in Section \ref{sec:RUClassif}. 

Regarding the over-sampling method, a new example from an important class is obtained by perturbing each numeric feature according to a random value following a normally distributed percentage of its standard deviation (with the standard deviation evaluated on the examples of that class). This means that, for a given value of \texttt{pert} defined by the user, each feature value ($i$) of the new example ($new_i$) is built as follows: $new_i=ex_i+rnorm(0,sd(i)\times pert) $, where $ex_i$ represents the original example value for feature $i$, and $sd(i)$ represents the evaluated standard deviation for feature $i$ in the class under consideration. For nominal features, the new example selects a label with a probability directly proportional to the frequency of the existing labels(with the frequency evaluated on the examples of that class).

The user may express which are the most relevant and the less important classes of the data set through the parameter \texttt{C.perc}. With this parameter the user also indicates the percentages of under and over-sampling to apply in each class. If a class is not referred in this parameter it will remain unchanged. Moreover, this parameter can also be set to "balance" or "extreme", cases where the under and over-sampling percentages are automatically estimated to achieve a balanced data set or a data set with the frequencies of the classes inverted. The perturbation applied to the numeric features is set using the \texttt{pert} parameter. Finally, the user may also specify if, when performing the random under-sampling strategy, it is allowed to perform sampling with repetition or not.

We present an example of the impact of applying this technique for different values of the parameters.


<<ir_GN>>=
set.seed(1234)
irB<- gaussNoiseClassif(Species~., data, C.perc="balance")
irE <- gaussNoiseClassif(Species~., data,C.perc="extreme")
irU1 <- gaussNoiseClassif(Species~., data,
                          C.perc=list(setosa=0.3, versicolor=1.5, virginica=4),
                          pert=0.5, repl=TRUE)
irU2 <- gaussNoiseClassif(Species~., data,
                          C.perc=list(versicolor=3, virginica=2), 
                          pert=0.05)
@


Table \ref{tab:iris_GN_table} presents the impact on the number of examples for the considered parameters of this strategy. In Figure \ref{fig:ir_GN_plot} we can observe the number of examples on the changed data sets for the parameters considered and Figure \ref{fig:ir_GN_plot2} presents the distribution of examples for those parameters.



<<iris_GN_table, results='asis',echo=FALSE>>=
nm <- c("Original", "irB", "irE","irU1", "irU2")

nm2 <- list(data, irB, irE,irU1, irU2)

res <- c(table(data$Species), table(irB$Species), table(irE$Species), table(irU1$Species), table(irU2$Species))

m <- matrix(res, nrow=5,ncol=3, byrow=TRUE, dimnames=list(nm, names(table(data$Species))))

xt <-xtable(m, caption="Number of examples in each class for different parameters of Gaussian Noise strategy.",label="tab:iris_GN_table")
print(xt,comment = FALSE, type = 'latex')

@



<<ir_GN_plot, echo=FALSE, fig.cap="Impact in the Original data set of several parameters in Gaussian noise strategy. ",out.height="0.5\\textheight">>=
DF <- rbind(data.frame(Dat="Original",obs=data$Species), data.frame(Dat="irB", obs=irB$Species), data.frame(Dat="irE", obs=irE$Species), data.frame(Dat="irU1", obs=irU1$Species), data.frame(Dat="irU2", obs=irU2$Species))
g1 <- ggplot(DF,aes(x=obs, fill=Dat, colour=Dat))+geom_histogram(binwidth=1, position="dodge", aes(group=Dat), colour="black")

g2 <- ggplot(DF,aes(x=Dat, fill=obs, colour=obs))+geom_histogram(binwidth=1, position="fill", aes(group=obs), colour="black")

plots <- list(g1, g2)

do.call(grid.arrange, plots)

@



<<ir_GN_plot2, echo=FALSE, fig.cap="The examples distribution for different parameters in Gaussian Noise strategy.">>=
  par(mfrow = c(2, 2))
  plot(data[, 1], data[, 2], pch =as.integer(data[, 3]), col=as.integer(data[,3]),
       main = "Original Data")
  plot(irB[,1], irB[,2], pch=as.integer(irB[,3]), col=as.integer(irB[,3]),
       main = "Balanced Data")
  plot(irE[,1], irE[,2], pch=as.integer(irE[,3]), col=as.integer(irE[,3]),
       main = "Data with Inverted Frequencies")
  plot(irU1[,1], irU1[,2], pch=as.integer(irU1[,3]), col=as.integer(irU1[,3]),
       main = "Data with User Defined Percentages")
@

\subsection{The Smote Algorithm}\label{sec:smoteClassif}

The well known Smote algorithm was proposed by \cite{CBOK02}. This algorithm presents a new strategy to address the problem of imbalanced domains through the generation of synthetic examples. The new synthetic cases are generated by interpolation of two cases from the minority (positive) class. To obtain a new example from the minority class, the algorithm uses a seed example from that class, and randomly selects one of its k nearest neighbors. Then, having the two examples, a new synthetic case is obtained by interpolating the examples features. This procedure is illustrated in Figure \ref{fig:smote_illust}.

<<smote_illust, echo=FALSE, fig.cap="Generation of synthetic examples through Smote algorithm.\\label{smote_illust}", out.height="0.4\\textheight", out.width="0.7\\textwidth">>=
#generate an artificial data set to illustrate the smote algorithm
set.seed(234)
plot(1:40, rnorm(40,2),pch="-", col="blue",xlab="", ylab="", xaxt="n", yaxt="n")
points(1:40, rnorm(40,2), pch="-", col="blue")
points(1:40, rnorm(40,2), pch="-", col="blue")
set.seed(123)
points(c(10:32, 17, 17,19), c(rnorm(24,-0.3,0.5),0,0.5), pch="+", col="red")
lines(c(17,19), c(0,0.5), col="orange", lwd=2)
draw.circle(19,0.5,4.7,nv=100,border=NULL,col=NA,lty=3,lwd=1)
points(17.6, 0.25*17.6-4.25, pch="+")
@

This over-sampling strategy was also combined with random under-sampling of the majority class in \cite{CBOK02}. 


Our implementation of this method is available through the \texttt{SmoteClassif} function and is able to deal with multiclass tasks. The user can specify which are the most important and the less relevant classes using the \texttt{C.perc} parameter. Using the same parameter the user also expresses the percentages of over and under-sampling that should be applied to each class. When the data set includes nominal features, the interpolation of two examples for these features is solved by randomly selecting among the two values of the seed examples. Two automatic methods are provided for both the estimation of the relevant classes and the percentages of over and under-sampling to apply. These methods are available through the \texttt{C.perc} parameter which can be set to "balance" or "extreme". In both cases, it is ensured that the new obtained data set includes roughly the same number of examples as the original data set. When "balance" or "extreme" are chosen, both the minority/majority classes and the percentages of over/under-sampling are automatically estimated. The "balance" option provides a balanced data set and the "extreme" option provides a data set with the classes frequencies inverted, i.e., the most frequent classes in the original data set are the less frequent on the new data set and vice-versa.

Finally, the user may also express if the under-sampling process may include repetition of examples or not (using the \texttt{repl} parameter), may choose the number of nearest neighbors to use (parameter \texttt{k}) and can select the distance metric to be used in the nearest neighbors evaluation (parameter \texttt{dist}). 


<<smote>>=
  mysmote1 <- smoteClassif(Species~., data, 
                           C.perc=list(setosa=0.6, virginica=1.5))
  mysmote2 <- smoteClassif(Species~., data, 
                           C.perc=list(setosa=0.2, versicolor=4), repl=TRUE)
  mysmote3 <- smoteClassif(Species~., data, 
                           C.perc=list(virginica=6, versicolor=2))
  smoteB <- smoteClassif(Species~., data, 
                           C.perc="balance")
  smoteE <- smoteClassif(Species~., data, 
                           C.perc="extreme")

@


Table \ref{tab:iris_smote_table} show the impact on the number of examples in each class for several parameters of smote technique.

<<smote_table, echo=FALSE, results='asis'>>=
nm <- c("Original", "mysmote1", "mysmote2","mysmote3", "smoteB", "smoteE")

res <- c(table(data$Species), table(mysmote1$Species), table(mysmote2$Species), table(mysmote3$Species), table(smoteB$Species), table(smoteE$Species))

m <- matrix(res, nrow=6,ncol=3, byrow=TRUE, dimnames=list(nm, names(table(data$Species))))

xt <-xtable(m, caption="Number of examples in each class for different parameters of smote strategy.",label="tab:iris_smote_table")
print(xt,comment = FALSE, type = 'latex')

@

Figures \ref{fig:smote_plot_hist} and \ref{fig:smote_plot} present the impact of applying smote strategy on an imbalanced data set.

<<smote_plot_hist, echo=FALSE, fig.cap="Impact in the Original data set of several parameters in smote strategy. ",out.height="0.5\\textheight">>=
DF <- rbind(data.frame(Dat="Original",obs=data$Species), data.frame(Dat="mysmote1", obs=mysmote1$Species), data.frame(Dat="mysmote2", obs=mysmote2$Species), data.frame(Dat="mysmote3", obs=mysmote3$Species), data.frame(Dat="smoteB", obs=smoteB$Species), data.frame(Dat="smoteE", obs=smoteE$Species))
g1 <- ggplot(DF,aes(x=obs, fill=Dat, colour=Dat))+geom_histogram(binwidth=1, position="dodge", aes(group=Dat), colour="black")


g2 <- ggplot(DF,aes(x=Dat, fill=obs, colour=obs))+geom_histogram(binwidth=1, position="fill", aes(group=obs), colour="black")

plots <- list(g1, g2)

do.call(grid.arrange, plots)
@


<<smote_plot, fig.cap="Smote strategy applied with different parameters", echo=FALSE>>=
par(mfrow = c(3, 2))
plot(data[, 1], data[, 2], pch = as.integer(data[, 3]), col=as.integer(data[,3]),
        main = "Original Data")
plot(mysmote1[, 1], mysmote1[, 2], pch = as.integer(mysmote1[,3]), col=as.integer(mysmote1[,3]),
        main = "User settings1")
plot(mysmote2[, 1], mysmote2[, 2], pch = as.integer(mysmote2[,3]), col=as.integer(mysmote2[,3]),
        main = "User settings2")
plot(mysmote3[, 1], mysmote3[, 2], pch = as.integer(mysmote3[,3]), col=as.integer(mysmote3[,3]),
        main = "User settings3")
plot(smoteB[, 1], smoteB[, 2], pch = as.integer(smoteB[,3]), col=as.integer(smoteB[,3]),
        main = "Balanced Data")
plot(smoteE[, 1], smoteE[, 2], pch = as.integer(smoteE[,3]), col=as.integer(smoteE[,3]),
        main = "Extreme ")

@


% ====================================================================
\section{Methods for Addressing Regression Tasks under Imbalanced Domains}

The problem of imbalanced domains also occurs for regression tasks. However, for these problems there are no classes defined. Instead, there are ranges of the target variable domain which are more important to the user (and usually less represented) while other regions of that variable are less important. Therefore, the notion of imbalanced domains for regression tasks depends on the definition of a continuous relevance function ($\phi()$) which expresses the importance of the target variable values across its domain. This function $\phi()$, varies between 0 and 1, where 0 represents points in the target variable domain which are not relevant and 1 identifies the most important values. Usually, the user is also asked to provide a relevance threshold (a numeric value in $[0,1]$) which helps to clearly distinguish between the important and unimportant values.

For a target variable with domain $[0,10]$ a possible relevance function could be the one represented in Figure \ref{fig:relev_ex}.

<<relev_ex, fig.cap="Example of a relevance function", echo=FALSE>>=
  y <- 0:10

   rel <- matrix(0,ncol=3,nrow=0)
   rel <- rbind(rel,c(0,1,0))
   rel <- rbind(rel,c(3,0,0))
   rel <- rbind(rel,c(6,1,0))
   rel <- rbind(rel,c(7,0.5,1))
   rel <- rbind(rel,c(10,0,0))
phiF.args <- phi.control(y,method="range",control.pts=rel)
#y.phi <- phi(y,phi.parms=phiF.args)


yrange <- range(y)
yplot <- seq(yrange[1],yrange[2],len=100)
yplot.phi <- phi(yplot,phi.parms=phiF.args)

plot(yplot,yplot.phi,type="l",
     ylab=expression(phi(y)),xlab=expression(y))
abline(h=0.5, lty=2, col=4)

text(x=9, y=0.52, labels="relevance threshold", cex=0.8, col=4)
mtext("0.5",side=2,col=4)
points(1.5,0.5, col=4)
points(4.5,0.5, col=4)
points(7,0.5, col=4)
#abline(h=-0.01,lwd=2, col=2)
lines(c(-0.2,1.5), c(-0.01,-0.01), col="green", lwd=3)
lines(c(1.5,4.5), c(-0.01,-0.01), col="red", lwd=3)
lines(c(4.5,7), c(-0.01,-0.01), col="green", lwd=3)
lines(c(7,10.2), c(-0.01,-0.01), col="red", lwd=3)

lines(c(1.5,1.5), c(0.5,0), col=4, lty=2)
lines(c(4.5,4.5), c(0.5,0), col=4, lty=2)
lines(c(7,7), c(0.5,0), col=4, lty=2)

@

For this particular regression task, the relevance function selected and the chosen relevance threshold of 0.5 characterize the most important ranges of the target variable and the bumps of relevance. In this case, we have established two bumps which include the most important values (also named "rare" cases) of the target variable ($[0, 1.5]$ and $[4.5, 7]$ represented in green in Figure \ref{fig:relev_ex}). On the other hand, the target values falling in the intervals $]1.5, 4.5[$ and $]7,10]$ (represented in red in Figure \ref{fig:relev_ex}) are the less relevant and "normal" cases.


The user has the responsibility of defining a relevance function suitable for the regression task he is considering. The \texttt{uba} package provides a mechanism to assist the user in this task. This method is called \texttt{range}, and depends on the introduction by the user of reference points for the $y$, and corresponding $\phi()$ and $\phi'()$ values. Using the capabilities provided by \texttt{uba} package, the relevance function may be manually defined with a 3-column matrix as follows:

<<method_range>>=
# relevance function represented in the previous example

## method: range
# the user should provide a matrix with y, phi(y), phi'(y)

rel <- matrix(0,ncol=3,nrow=0)

# for the target value of zero the relevance function should be one and
# the derivative at that point should be zero
rel <- rbind(rel,c(0,1,0)) 

# for the value three the relevance assigned is zero and the derivative is zero
rel <- rbind(rel,c(3,0,0))
rel <- rbind(rel,c(6,1,0))
rel <- rbind(rel,c(7,0.5,1))
rel <- rbind(rel,c(10,0,0))
# after defining the relevance function the user may obtain the 
# phi values as follows:

# use method "range" when defining a matrix
phiF.args <- phi.control(y,method="range",control.pts=rel)

# obtain the relevance values for the target variable y
y.phi <- phi(y,phi.parms=phiF.args)

@

In order to facilitate the user task, \texttt{uba} package also provides an automatic mechanism for defining the relevance function. This automatic method, called \texttt{extremes} is based on the boxplot of the target variable values and assigns a larger importance to the least represented values. We now provide an example of how to use this automatic method.

<<method_extremes>>=

## method: extremes

## for considering only the high extremes
phiF.args <- phi.control(y,method="extremes",extr.type="high")
y.phi <- phi(y,phi.parms=phiF.args)

## for considering only the low extremes
phiF.args <- phi.control(y,method="extremes",extr.type="low")
y.phi <- phi(y,phi.parms=phiF.args)

## for considering both extreme types (low and high)
phiF.args <- phi.control(y,method="extremes",extr.type="both")
y.phi <- phi(y,phi.parms=phiF.args)


@

All the existing methods for regression tasks under imbalanced domains depend on the definition of a relevance function, and the majority of them also rely on a relevance threshold established by the user.


\subsection{Random Under-sampling}\label{sec:RURegress}

Random under-sampling strategy for regression problems was first proposed by \cite{torgo2013smote}. This strategy is similar to the strategy presented for classification. It depends on the definition of both a relevance function and a relevance threshold. In this proposal, all the target values below the relevance threshold were considered normal and uninteresting and thus were regarded as candidates to be under-sampled. The user was also asked another parameter $n_u$ which represented the number of unimportant cases that should be selected for each important case. This means that the $n_u$ value established the proportion between normal (unimportant) and rare (important) cases that the under-sampled data set should contain.


In the implementation of this strategy in \UBL, regarding the relevance function definition, the user has available the two methods (range and extremes) provided by \texttt{uba} package that were previously described. This means that the user may define as many relevance bumps as wanted. Parameter \texttt{rel} is used to indicate the relevance function. This can be accomplished by either using the automatic method (setting \texttt{rel} to "auto"- the default) or using the range method by providing a 3-column matrix.  It is also necessary for the user to point out a relevance threshold through the \texttt{thr.rel} parameter. Having this defined, all the target variable values with relevance below the relevance threshold are candidates to be under-sampled. Finally, the user can express using the \texttt{C.perc} parameter which under-sampling percentage should be applied in each bump with uninteresting values, or alternatively this parameter may be set to "balance" or "extreme". If "balance" is chosen the under-sampling percentage is automatically estimated in order to balance the normal/important and rare/unimportant cases. On the other hand, the "extreme" option will invert the existing frequencies. The following example shows how these parameters can be set.

<<dat>>=
# use algae data set with NA's removed
library(DMwR)
data(algae)
clean.algae <- algae[complete.cases(algae),]

# We start by using the automatic method for the relevance function
# Since this is the default behaviour, we can simply not mention the
# "rel" parameter

algB <- randUnderRegress(a7~., clean.algae, C.perc="balance")
algE <- randUnderRegress(a7~., clean.algae, C.perc="extreme")

# the automatic method for the relevance function provides only one bump 
# with values to be under-sampled, thus we only need to indicate one percentage
algMy <- randUnderRegress(a7~., clean.algae, C.perc=list(0.5))

@

The impact of the previous strategies can be visualized in Figure \ref{fig:RU_ex1}.
<<RU_ex1, fig.cap="Relevance function and density of the target variable in the original and new data sets using Random Under-sampling strategy", echo=FALSE>>=
par(mar = c(5,5,2,5))
plot(density(clean.algae$a7), xlab=expression(y), main="")
lines(density(algB$a7), col=3)
lines(density(algE$a7), col=4)
lines(density(algMy$a7), col=6)

y <- sort(resp(a7~.,clean.algae))

pc <- phi.control(y, method="extremes")
y.relev <- phi(y,pc)

par(new=TRUE)
plot(y,y.relev, lty=2, col=2, lwd=3, axes=F, ylab=NA, xlab=NA,type="l")
axis(4, xaxt="n",col =2, col.axis =2 , lwd = 2)
mtext(expression(phi(y)),4, col=2, line=3)
legend(22,0.9, c("clean.algae", "algB", "algE", "algMy",expression(phi())), col=c(1,3,4,6,2), lty=c(1,1,1,1,2), lwd=c(1,1,1,1,2), bty="n", text.col=c(1,1,1,1,2))
@


Suppose, for the same data set, that we want to consider as relevant the target values close to 5 and above 25. We can define a relevance function that expresses this:

<<rel_RU>>=

rel <- matrix(0,ncol=3,nrow=0)

# add zero relevance for the target values before five
rel <- rbind(rel, c(0,0,0))
rel <- rbind(rel,c(4,0,0))

# add maximum relevance for the target values close to 5
rel <- rbind(rel, c(5,1,0))

# add some unimportant target values 

rel <- rbind(rel, c(7,0,0))
rel <- rbind(rel, c(18,0,0))

# add maximum relevance to points close to and above 20

rel <- rbind(rel, c(20,1,0))
rel <- rbind(rel, c(30,1,0))

@

Now, having defined the relevance threshold as 0.7, we will apply the random under-sampling strategy in the two ranges with uninteresting values of the target variable:

<<RRU>>=
RUnew <- randUnderRegress(a7~., clean.algae, rel=rel, thr.rel=0.7,
                          C.perc=list(0.2,0.8))
RUB2 <- randUnderRegress(a7~., clean.algae, rel=rel, thr.rel=0.7, 
                         C.perc="balance")
RUE2 <- randUnderRegress(a7~., clean.algae, rel=rel, thr.rel=0.7, 
                         C.perc="extreme")
@

The impact of the new strategies and the relevance function defined can be visualized in Figure \ref{fig:RU_ex2}.
<<RU_ex2, fig.cap="Relevance function and density of the target variable in the original and new data sets with Random Under-sampling strategy.", echo=FALSE>>=
par(mar = c(5,5,2,5))
plot(density(clean.algae$a7),xlab=expression(y), main="")
lines(density(RUnew$a7), col=3)
lines(density(RUB2$a7), col=4)
lines(density(RUE2$a7), col=6)

y <- sort(resp(a7~.,clean.algae))

pc <- phi.control(y, method="range", control.pts=rel)
y.relev <- phi(y,pc)

par(new=TRUE)
plot(y,y.relev, lty=2, col=2, lwd=3, axes=F, ylab=NA, xlab=NA,type="l")
axis(4, xaxt="n",col =2, col.axis =2 , lwd = 2)
mtext(expression(phi(y)),4, col=2, line=3)
legend(22,0.9, c("clean.algae", "RUnew", "RUB2", "RUE2",expression(phi())), col=c(1,3,4,6,2), lty=c(1,1,1,1,2), lwd=c(1,1,1,1,2), bty="n", text.col=c(1,1,1,1,2))

@

We must also highlight that this strategy entails costs which can not be disregarded namely on the total number of examples in the modified data sets. If we are considering a large data set, possibly removing 100 points may have a negligible impact. However, if the data set is already small, removing 100 examples may have an huge impact. 

This can be observed in the previous examples. In fact, the \texttt{C.perc} parameter must be thought carefully due to the consequences on the total number of examples. In Table \ref{tab:RUReg_table} we can check the impact of the several strategies on the data set for the two relevance functions considered (the obtained through the automatic method and the defined with a 3-column matrix).

<<RU_table, echo=FALSE, results='asis' >>=

nm <- list(clean.algae, algB, algE, algMy, RUnew, RUB2, RUE2)
names <- c("clean.algae", "algB", "algE", "algMy", "RUnew", "RUB2", "RUE2")
m <- matrix(sapply(nm, nrow),nrow=1, ncol=7, dimnames=list("nr. examples", names))

xt <-xtable(m, caption="Total number of examples in each data set for different parameters of random under-sampling strategy.",label="tab:RUReg_table")

print(xt,comment = FALSE, type = 'latex')
@



\subsection{Random Oversampling}\label{sec:RORegress}

The Random over-sampling method here presented is an adaptation of the Random over-sampling method proposed for classification tasks using the previously presented relevance function for regression tasks under imbalanced domains. This technique is available with \texttt{randomOverRegress} function, and is simply based on the introduction of random copies of examples of the original data set. These replicas are only introduced in the most important ranges of the target variable, i.e., in the ranges where the relevance is above a user-defined threshold. Similarly to what happened in Random Under-sampling, the user may define its own relevance function or use the automatic method provided by \texttt{uba} package to generate one. It is also the user responsibility to define the relevance threshold (using the \texttt{thr.rel} parameter) and the percentages of over-sampling to apply in each bump of relevance (through the \texttt{C.perc} parameter). Alternatively, the user may set the \texttt{C.perc} parameter as "balance" or "extreme", cases which automatically evaluate the percentages of over-sampling to apply for obtaining a new balanced data set or for inverting the frequencies of examples in the defined bumps.
In the following example we can see how to use this function.

<<RO_autoRel>>=
# using the automatic method for defining the relevance function and
# the default threshold of 0.5
Alg.my <- randOverRegress(a7~., clean.algae, C.perc=list(2.5))
Alg.Bal <- randOverRegress(a7~., clean.algae, C.perc="balance")
Alg.Ext0.5 <- randOverRegress(a7~., clean.algae, C.perc="extreme")

# change the relevance threshold to 0.9
Alg.Ext0.9 <- randOverRegress(a7~., clean.algae, thr.rel=0.9, C.perc="extreme")
@


Figure \ref{fig:RO_ex1} shows the impact of this method for several parameters.

<<RO_ex1, fig.cap="Relevance function and density of the target variable in the original and new data sets using Random over-sampling strategy.", echo=FALSE>>=
par(mar = c(5,5,2,5))
plot(density(clean.algae$a7), xlab=expression(y), main="")
lines(density(Alg.my$a7), col=3)
lines(density(Alg.Bal$a7), col=4)
lines(density(Alg.Ext0.5$a7), col=6)
lines(density(Alg.Ext0.9$a7), col=7)

y <- sort(resp(a7~.,clean.algae))

pc <- phi.control(y, method="extremes")
y.relev <- phi(y,pc)

par(new=TRUE)
plot(y,y.relev, lty=2, col=2, lwd=3, axes=F, ylab=NA, xlab=NA,type="l")
axis(4, xaxt="n",col =2, col.axis =2 , lwd = 2)
mtext(expression(phi(y)),4, col=2, line=3)
legend(22,0.9, c("clean.algae", "Alg.my", "Alg.Bal", "Alg.Ext0.5", "Alg.Ext0.9",expression(phi())), col=c(1,3,4,6,7,2), lty=c(1,1,1,1,1,2), lwd=c(1,1,1,1,1,2), bty="n", text.col=c(1,1,1,1,1,2))
@

This method also carries a strong impact on the total number of examples in the modified data set. While the random Under-sampling method is able to produce a significant reduction of the data set, the random over-sampling technique will increase, sometimes drastically, the data set size. Table \ref{tab:ROReg_table} shows the impact of the previous examples on the total number of examples of used the data set.

<<RO_table, echo=FALSE, results='asis' >>=

nm <- list(clean.algae, Alg.my, Alg.Bal, Alg.Ext0.5, Alg.Ext0.9)
names <- c("clean.algae", "Alg.my", "Alg.Bal", "Alg.Ext0.5", "Alg.Ext0.9")
m <- matrix(sapply(nm, nrow), nrow=1, ncol=5, dimnames=list("nr. examples", names))

xt <-xtable(m, caption="Total number of examples in each data set for different parameters of random over-sampling strategy.",label="tab:ROReg_table")

print(xt,comment = FALSE, type = 'latex')
@

As expected, all the data sets have an increased size. However, for the \texttt{Alg.Ext0.9} data set, the size was increased approximately \Sexpr{round(nrow(Alg.Ext0.9)*100/nrow(clean.algae),0)}\%. This "side effect" must be taken into consideration when applying this technique because it may impose constraints on the used learners. We must also highlight that, although the data set size can be strongly increased, we are in fact only introducing replicas of already existing examples, and thus no new information is being inserted.



\subsection{Generation of synthetic examples by the introduction of Gaussian Noise}\label{sec:gnRegress}

The generation of synthetic examples through the introduction of small perturbations based on Gaussian Noise was a strategy proposed for classification tasks \cite{lee1999regularization, lee2000noisy}. The main idea of this strategy is to generate new synthetic examples with a desired class label, by perturbing the features of examples of that class a certain amount of the respective standard deviation. 

We have adapted this over-sampling technique to regression problems and have combined it with the random under-sampling method. To accomplish this it is required that the user defines a relevance function and a relevance threshold. The examples which have a target variable value with relevance higher than the threshold set will be over-sampled, and the remaining will be randomly under-sampled. The under-sampling strategy used is the same described in Section \ref{sec:RURegress}. For the over-sampling strategy we use the same procedure which was described for classification tasks in Section \ref{sec:gnClassif}. The only difference on the over-sampling method is in the target variable value. For classification tasks, the target variable value was easily assigned: it was the rare class under consideration. For regression tasks we have decided to extend the technique applied for numeric features also to the target variable. This means that the new example target variable value is obtained by a random normal perturbation of the original target value based on the target value standard deviation.

In order to use this method the user must provide a relevance function through the \texttt{rel} parameter (or use the automatic method for estimating it), a threshold on the relevance (parameter \texttt{thr.rel}) and the perturbation to be used (parameter \texttt{pert}). Moreover, the user may also express using the parameter \texttt{C.perc} the percentages of over and under-sampling to apply in each bump defined, or alternatively he may set this parameter to "balance" or "extreme". Similarly to behavior described in the previous techniques, setting this parameter to "balance" or "extreme" causes the percentages of over and under-sampling to be automatically estimated. The option "balance" will try to distribute the examples evenly across the existing bumps while maintaining the total number of examples in the modified data set. If the choice is "extreme" then the frequencies of the examples in the bumps will be inverted. The user can also indicate if the under-sampling process can be made with repetition of examples or not using the \texttt{repl} parameter.

We now show some examples of usage of the function \texttt{gaussNoiseRegress}.
<<GN_1>>=
# relevance function estimated automatically has two bumps
# defining the desired percentages of under and over-sampling to apply
C.perc=list(0.5, 3)
# define the relevance threshold
thr.rel=0.8
mygn <- gaussNoiseRegress(a7~., clean.algae, thr.rel=thr.rel, C.perc=C.perc)
gnB <- gaussNoiseRegress(a7~., clean.algae, thr.rel=thr.rel, C.perc="balance")
gnE <- gaussNoiseRegress(a7~., clean.algae, thr.rel=thr.rel, C.perc="extreme")

@

Figures \ref{fig:GN_plot1} and \ref{fig:GN_plot2} show the impact of this strategy, for the parameters considered, on the examples distribution. In Figure \ref{fig:GN_plot2} we selected two numeric features ("Cl" and "a5") to visualize the impact on the data sets.

<<GN_plot1, fig.cap="Relevance function and density of the target variable in the original and new data sets using Gaussian noise strategy.", echo=FALSE>>=
par(mar = c(5,5,2,5))
plot(density(clean.algae$a7), xlab=expression(y), main="")
lines(density(mygn$a7), col=3)
lines(density(gnB$a7), col=4)
lines(density(gnE$a7), col=6)

names <- c("clean.algae", "mygn", "gnB", "gnE")
y <- sort(resp(a7~.,clean.algae))
pc <- phi.control(y, method="extremes")
y.relev <- phi(y,pc)

par(new=TRUE)
plot(y,y.relev, lty=2, col=2, lwd=1, axes=F, ylab=NA, xlab=NA,type="l")
axis(4, xaxt="n",col =2, col.axis =2 , lwd = 1)
mtext(expression(phi(y)),4, col=2, line=3)
legend(22,0.9, c("clean.algae", "mygn", "gnB", "gnE",expression(phi())), col=c(1,3,4,6,2), lty=c(1,1,1,1,2), lwd=c(1,1,1,1,1), bty="n", text.col=c(1,1,1,1,2))
@




<<GN_plot2,fig.cap="The impact of Gaussian Noise strategy.",out.width="0.8\\textwidth", echo=FALSE>>=
par(mfrow = c(2, 2))
plot(clean.algae[,16], clean.algae[,6], col= ifelse(clean.algae[, 18]>5,2,3), pch=ifelse(clean.algae[,18]>5,"+", "-"), main="Original data", xlim=c(0,45), ylim=c(0,400))
plot(mygn[,16], mygn[,6], col= ifelse(mygn[, 18]>5,2,3), pch=ifelse(mygn[,18]>5,"+", "-"), main="user specified percentages", xlim=c(0,45), ylim=c(0,400))
par(xpd=TRUE)
legend("topright", inset=c(0,0),col=c(2,3), c("important/rare cases", "normal/uninteresting cases"),pch=c("+", "-"), bty="n")
plot(gnB[,16], gnB[,6], col= ifelse(gnB[, 18]>5,2,3),pch=ifelse(gnB[,18]>5,"+", "-"), main="balance method", xlim=c(0,45), ylim=c(0,400))
plot(gnE[,16], gnE[,6], col= ifelse(gnE[, 18]>5,2,3), pch=ifelse(gnE[,18]>5,"+", "-"), main="extreme method", xlim=c(0,45), ylim=c(0,400))

@



In the following example we check the impact of changing the perturbation introduced.

<<gn_balance_pert_eval>>=
# the default uses the value of 0.1 for "pert" parameter
gnB1 <- gaussNoiseRegress(a7~., clean.algae, thr.rel=thr.rel, C.perc="balance")

# try two different values for "pert" parameter
gnB2 <- gaussNoiseRegress(a7~., clean.algae, thr.rel=thr.rel, C.perc="balance",
                          pert=0.5)
gnB3 <- gaussNoiseRegress(a7~., clean.algae, thr.rel=thr.rel, C.perc="balance",
                          pert=0.01)

@



The impact of changing the parameter \texttt{pert} is represented in Figure \ref{fig:GN_plot3}.
<<GN_plot3,fig.cap="Impact of changing the pert parameter in Gaussian Noise strategy.",out.width="0.8\\textwidth", echo=FALSE>>=
par(mfrow = c(2, 2))
plot(clean.algae[,16], clean.algae[,6], col= ifelse(clean.algae[, 18]>5,2,3), pch=ifelse(clean.algae[,18]>5,"+", "-"), main="Original data", xlim=c(-5,45), ylim=c(0,400))
plot(gnB1[,16], gnB1[,6], col= ifelse(gnB1[, 18]>5,2,3), pch=ifelse(gnB1[,18]>5,"+", "-"), main="pert=0.1", xlim=c(-5,45), ylim=c(0,400))
par(xpd=TRUE)
legend("topright", inset=c(0,0),col=c(2,3), c("important/rare cases", "normal/uninteresting cases"),pch=c("+", "-"), bty="n")
plot(gnB2[,16], gnB2[,6], col= ifelse(gnB2[, 18]>5,2,3),pch=ifelse(gnB2[,18]>5,"+", "-"), main="pert=0.5", xlim=c(-5,45), ylim=c(0,400))
plot(gnB3[,16], gnB3[,6], col= ifelse(gnB3[, 18]>5,2,3), pch=ifelse(gnB3[,18]>5,"+", "-"), main="pert=0.01", xlim=c(-5,45), ylim=c(0,400))

@


\subsection{The SmoteR Algorithm}\label{sec:smoteR}

The SmoteR algorithm was presented in \cite{torgo2013smote}. This proposal is an adaptation for regression problems under imbalanced domains of the existing smote algorithm for classification tasks. As with other methods addressing regression tasks under imbalanced data distributions it is the user responsability to provide a relevance function and a relevance threshold. This function determines which are the relevant and the unimportant examples. This algorithm combines an over-sampling strategy by interpolation of examples with a random under-sampling approach. For the generation of new examples by interpolation, the same procedure proposed in smote algorithm is used. Regarding the generation of the target variable value of the new generated examples the proposed smoteR algorithm uses an weighted average of the values of target variable of the two examples used. The weights are calculated as an inverse function of the distance of the generated case to each of the two seed examples. This means that, the further away the new example is from the seed case less weight will be given for the generation of the target variable value. The random under-sampling approach is applied in the bumps containing the normal and unimportant cases. 

The smoteR algorithm is available through the \texttt{smoteRegress} function. The user may define its own relevance function or use the automatic method, as in the previously described techniques. The user must also define the relevance threshold. 
Regarding the generation of examples it is required to specify the number of nearest neighbors to consider in smoteR algorithm. This is available through the parameter \texttt{k} and the default is set to 5. The user may then use the \texttt{C.perc} parameter to either express the percentages of under and over-sampling to use in each bump of relevance or to set which automatic method should be used for determining these percentages. Similarly to the other approaches, the automatic methods available are "balance" and "extreme" which estimate both where to apply the under/over-sampling and the corresponding percentages. The method "balance" changes the examples distribution by assigning roughly the same number of examples to each bump while the "extreme" method inverts the frequencies of each bump. Both methods approximately maintain the total number of examples. The parameter \texttt{repl} allows to select if the random under-sampling strategy is applied with repetition of examples or not. The user can also specify which distance function should be used for the nearest neighbors computation using the \texttt{dist} parameter. 

The following examples illustrate how this method can be used.

<<smoteR_rel1, fig.cap="Relevance function obtained automatically for the clean.algae data set">>=

# we will use the automatic method for defining the relevance function and will
# set the relevance threshold to 0.8 
# this method splits the data set in two: a first range of values normal and less
# important and a second range with the interesting cases

# to check this, we can plot the relevance function obtained automatically
# as follows:

y <- sort(clean.algae$a7)
phiF.args <- phi.control(y,method="extremes",extr.type="both")
y.phi <- phi(y,phi.parms=phiF.args)

# plot the relevance function
plot(y,y.phi,type="l",
     ylab=expression(phi(y)),xlab=expression(y))

#add the relevance threshold to the plot
abline(h=0.8, col=3, lty=2)
@

Figure \ref{fig:smoteR_rel1} shows that we are considering two different bumps: a first bump with the normal and less important cases and a second bump with the rare and interesting cases. Thus, to address this problem we can do the following:

<<smoteR_ex1>>=
# we have two bumps: the first must be under-sampled and the second over-sampled. 
# Thus, we can chose the following percentages: 
thr.rel=0.8
C.perc=list(0.1, 8) 
# using these percentages and the relevance threshold of 0.8 with all the other parameters default values
# it is necessary to set the distance function to "HEOM" because the data set contains nominal and numeric features
mysm <- smoteRegress(a7~., clean.algae, thr.rel=thr.rel, dist="HEOM", C.perc=C.perc)

# use the automatic method for obtaining a balanced data set
smB <- smoteRegress(a7~., clean.algae, thr.rel=thr.rel, dist="HEOM", C.perc="balance")

# use the automatic method for invert the frequencies of the bumps
smE <- smoteRegress(a7~., clean.algae, thr.rel=thr.rel, dist="HEOM", C.perc="extreme")

@

This strategy changes the examples distribution as shown in Figure \ref{fig:smoteR_plot1}.

<<smoteR_plot1, fig.cap="Relevance function and density of the target variable in the original and new data sets using smoteR strategy.", echo=FALSE>>=
par(mar = c(5,5,2,5))
plot(density(clean.algae$a7), xlab=expression(y), main="")
lines(density(mysm$a7), col=3)
lines(density(smB$a7), col=4)
lines(density(smE$a7), col=6)

names <- c("clean.algae", "mysm", "smB", "smE")
y <- sort(resp(a7~.,clean.algae))
pc <- phi.control(y, method="extremes")
y.relev <- phi(y,pc)

par(new=TRUE)
plot(y,y.relev, lty=2, col=2, lwd=1, axes=F, ylab=NA, xlab=NA,type="l")
axis(4, xaxt="n",col =2, col.axis =2 , lwd = 1)
mtext(expression(phi(y)),4, col=2, line=3)
legend(22,0.9, c("clean.algae", "mysm", "smB", "smE",expression(phi())), col=c(1,3,4,6,2), lty=c(1,1,1,1,2), lwd=c(1,1,1,1,1), bty="n", text.col=c(1,1,1,1,2))
@


We can also obtain the number of examples that each bump contains. Table \ref{tab:smoteR_1} show that distribution for the considered strategies.

<<smoteR_count1, echo=FALSE>>=
# check the number of examples in each bump of relevance
y <- sort(resp(a7~.,clean.algae))
pc <- phi.control(y, method="extremes")
y.relev <- phi(y,pc)

y.rel.mysm <- phi(resp(a7~.,mysm),pc)
y.rel.smB <- phi(resp(a7~.,smB),pc)
y.rel.smE <- phi(resp(a7~.,smE),pc)

imp <-list(y.relev, y.rel.mysm, y.rel.smB, y.rel.smE)
res <- sapply(imp, function(x)c(length(which(x<thr.rel)), length(which(x>=thr.rel))))

m <- matrix(t(res), nrow=4, ncol=2, dimnames=list(names, c("first bump", "second bump")))
@


<<smoteR_1, echo=FALSE, results='asis'>>=
xt <-xtable(m, caption="Number of examples in each bump of relevance for different parameters of smoteR strategy.",label="tab:smoteR_1")
print(xt,comment = FALSE, type = 'latex')

@

In Figure \ref{fig:smoteR_1bar} we can visualize the impact of these approaches on the examples distribution for each bump of relevance.

<<smoteR_1bar, echo=FALSE, fig.cap="Impact in the distribution of examples for several parameters in smoteR strategy. ",out.height="0.5\\textheight">>=
DF <- rbind(data.frame(Dat="Original", obs=c(rep("first.bump",res[1]), rep("second.bump", res[2]))), data.frame(Dat="mysm", obs=c(rep("first.bump",res[3]), rep("second.bump", res[4]))), data.frame(Dat="smB", obs=c(rep("first.bump",res[5]), rep("second.bump", res[6]))), data.frame(Dat="smE", obs=c(rep("first.bump",res[7]), rep("second.bump", res[8]))))

g1 <- ggplot(DF,aes(x=obs, fill=Dat, colour=Dat))+geom_histogram(binwidth=1, position="dodge", aes(group=Dat), colour="black")

g2 <- ggplot(DF,aes(x=Dat, fill=obs, colour=obs))+geom_histogram(binwidth=1, position="fill", aes(group=obs), colour="black")

plots <- list(g1, g2)

do.call(grid.arrange, plots)

@

In Figure \ref{fig:smoteR_fig2} we can visualize the impact of the several strategy variants considered for two numeric features selected (the "mnO2" and "Cl" features).

<<smoteR_fig2,fig.cap="The impact of smoteR strategy.",out.width="0.8\\textwidth", echo=FALSE>>=
  par(mfrow = c(2, 2))
plot(clean.algae[,5], clean.algae[,6], col= ifelse(clean.algae[, 18]>5,2,3), pch=ifelse(clean.algae[,18]>5,"+", "-"), main="Original data", xlab="mnO2", ylab="Cl", ylim=c(0,400))
plot(mysm[,5], mysm[,6], col= ifelse(mysm[, 18]>5,2,3), ylim=c(0,400), pch=ifelse(mysm[,18]>5,"+", "-"), main="user specified percentages", xlab="mnO2", ylab="Cl")
par(xpd=TRUE)
legend("topright", inset=c(0,0),col=c(2,3), c("important/rare cases", "normal/uninteresting cases"),pch=c("+", "-"), bty="n")
plot(smB[,5], smB[,6], col= ifelse(smB[, 18]>5,2,3),pch=ifelse(smB[,18]>5,"+", "-"), main="balance method", xlab="mnO2", ylab="Cl", ylim=c(0,400))
plot(smE[,5], smE[,6], col= ifelse(smE[, 18]>5,2,3), pch=ifelse(smE[,18]>5,"+", "-"), main="extreme method", xlab="mnO2", ylab="Cl", ylim=c(0,400))

@



\subsection{Importance Sampling}\label{sec:IS}

The Importance Sampling method is a new proposal whose main idea is to use the relevance function defined for a regression problem as a probability for resampling the examples combining over with under-sampling. This method simply removes some of the examples and includes in the data set replicas of other existing examples. There is no generation of new synthetic examples. For the over-sampling strategy, replicas of examples are introduced by selecting examples according to the relevance function defined, i.e., the higher the relevance of an example, the higher is the probability of being selected as a new replica to include. The under-sampling strategy selects examples to remove according to the function $1-\phi(y)$, i.e, the higher the relevance value of an example, the lower will be the probability of removing it.

This method includes two main behaviors which can be distinguished by the definition or not of a threshold on the relevance function. This means that, if the user decides to chose a relevance threshold the strategy will take this value into consideration with under and over-sampling being applied only on the defined bumps. However, if the user decides not to set a threshold on the relevance then over sampling and under-sampling strategies will also be applied but without a strict bound, i.e., there may be regions of the target variable values where under-sampling and over-sampling are performed together.

The strategy that depends on the definition of a relevance threshold, has the relevance bumps well defined. For these bumps, the user has several alternatives available through the \texttt{C.perc} parameter: the percentages of over and under-sampling to apply may be explicitly defined, or one of the options "balance" or "extreme" may be chosen. These last two option for the \texttt{C.perc} parameter allow to estimate the under and over-sampling percentages automatically. The option "balance" allows to obtain  a balanced data set across the different existing bumps. The "extreme" option will produce a new data set with the examples frequencies in the bumps inverted. In this setting, there is no range of the target variable where both under and over-sampling techniques are applied. 

As previously mentioned, there is the possibility of not defining a relevance threshold, and simply use the relevance function to decide which examples should be replicated and which should be removed. In this case, the user does not set a threshold on the relevance, but he can define the importance that over and under-sampling should have. In this case, the \texttt{C.perc} parameter is ignored and two other parameters(\texttt{U} and \texttt{O}) are considered instead. The parameters \texttt{U} and \texttt{O} allow the user to define (in a $[0,1] scale$) the importance that the under/over-sampling have, i.e, these parameters assign a weight to the two methods. The higher is \texttt{O} parameter, the higher is the number of replicas selected. In a similar way, the higher is \texttt{U} parameter the higher is the number of examples removed.

The function \texttt{ImpSampRegress} allows the use of Importance Sampling strategy. Some examples on how to use this approach are provided next.
<<IS_1>>=
# relevance function estimated automatically has two bumps
# using the strategy with threshold definition
C.perc=list(0.2,6)
myIS <- ImpSampRegress(a7~., clean.algae, thr.rel=0.8,C.perc=C.perc)
ISB <- ImpSampRegress(a7~., clean.algae, thr.rel=0.8, C.perc="balance")
ISE <- ImpSampRegress(a7~., clean.algae, thr.rel=0.8, C.perc="extreme")

@

Figures \ref{fig:IS_plot1} and \ref{fig:IS_plot2} show the impact on the density and distribution of the examples for the new data sets obtained with Importance Sampling strategy.
<<IS_plot1, fig.cap="Relevance function and density of the target variable in the original and new data sets using Importance Sampling strategy.", echo=FALSE>>=
par(mar = c(5,5,2,5))
plot(density(clean.algae$a7), xlab=expression(y), main="")
lines(density(myIS$a7), col=3)
lines(density(ISB$a7), col=4)
lines(density(ISE$a7), col=6)

names <- c("clean.algae", "myIS", "ISB", "ISE")
y <- sort(resp(a7~.,clean.algae))
pc <- phi.control(y, method="extremes")
y.relev <- phi(y,pc)

par(new=TRUE)
plot(y,y.relev, lty=2, col=2, lwd=1, axes=F, ylab=NA, xlab=NA,type="l")
axis(4, xaxt="n",col =2, col.axis =2 , lwd = 1)
mtext(expression(phi(y)),4, col=2, line=3)
legend(22,0.9, c(names,expression(phi())), col=c(1,3,4,6,2), lty=c(1,1,1,1,2), lwd=c(1,1,1,1,1), bty="n", text.col=c(1,1,1,1,2))
@


<<IS_plot2,fig.cap="Impact of Importance Sampling strategy.",out.width="0.8\\textwidth", echo=FALSE>>=
par(mfrow = c(2, 2))
plot(clean.algae[,5], clean.algae[,6], col= ifelse(clean.algae[, 18]>5,2,3), pch=ifelse(clean.algae[,18]>5,"+", "-"), main="Original data",ylim=c(0,400))
plot(jitter(myIS[,5]), jitter(myIS[,6]), col= ifelse(myIS[, 18]>5,2,3), pch=ifelse(myIS[,18]>5,"+", "-"), main="User-defined percentages",ylim=c(0,400))
par(xpd=TRUE)
legend("topright", inset=c(0,0),col=c(2,3), c("important/rare cases", "normal/uninteresting cases"),pch=c("+", "-"), bty="n")
plot(jitter(ISB[,5]), jitter(ISB[,6]), col= ifelse(ISB[, 18]>5,2,3),pch=ifelse(ISB[,18]>5,"+", "-"), main="balance",ylim=c(0,400))
plot(jitter(ISE[,5]), jitter(ISE[,6]), col= ifelse(ISE[, 18]>5,2,3), pch=ifelse(ISE[,18]>5,"+", "-"), main="extreme",ylim=c(0,400))

@

We now provide some examples of the use of this strategy without the definition of a relevance threshold.

<<IS_2>>=
# relevance function is also estimated automatically
# the default is not to use a relevance threshold and to assign equal 
# importance to under and over-sampling, i.e., U=0.5 and O=0.5
ISD <- ImpSampRegress(a7~., clean.algae) 
IS1 <- ImpSampRegress(a7~., clean.algae, U=0.9, O=0.2)
IS2 <- ImpSampRegress(a7~., clean.algae, U=0.5, O=0.8)

@

Figures \ref{fig:IS_plot3} and \ref{fig:IS_plot4} show the impact on the density and distribution of the examples for the new data sets obtained with Importance Sampling strategy.
<<IS_plot3, fig.cap="Relevance function and density of the target variable in the original and new data sets using Importance Sampling strategy.", echo=FALSE>>=
par(mar = c(5,5,2,5))
plot(density(clean.algae$a7), xlab=expression(y), main="")
lines(density(ISD$a7), col=3)
lines(density(IS1$a7), col=4)
lines(density(IS2$a7), col=6)

names <- c("clean.algae", "ISD", "IS1", "IS2")
y <- sort(resp(a7~.,clean.algae))
pc <- phi.control(y, method="extremes")
y.relev <- phi(y,pc)

par(new=TRUE)
plot(y,y.relev, lty=2, col=2, lwd=1, axes=F, ylab=NA, xlab=NA,type="l")
axis(4, xaxt="n",col =2, col.axis =2 , lwd = 1)
mtext(expression(phi(y)),4, col=2, line=3)
legend(22,0.9, c(names,expression(phi())), col=c(1,3,4,6,2), lty=c(1,1,1,1,2), lwd=c(1,1,1,1,1), bty="n", text.col=c(1,1,1,1,2))
@


<<IS_plot4,fig.cap="Impact of Importance Sampling strategy.",out.width="0.8\\textwidth", echo=FALSE>>=
par(mfrow = c(2, 2))
plot(clean.algae[,5], clean.algae[,6], col= ifelse(clean.algae[, 18]>5,2,3), pch=ifelse(clean.algae[,18]>5,"+", "-"), main="Original data",ylim=c(0,400))
plot(jitter(ISD[,5]), jitter(ISD[,6]), col= ifelse(ISD[, 18]>5,2,3), pch=ifelse(ISD[,18]>5,"+", "-"), main="U=0.5 O=0.5",ylim=c(0,400))
par(xpd=TRUE)
legend("topright", inset=c(0,0),col=c(2,3), c("important/rare cases", "normal/uninteresting cases"),pch=c("+", "-"), bty="n")
plot(jitter(IS1[,5]), jitter(IS1[,6]), col= ifelse(IS1[, 18]>5,2,3),pch=ifelse(IS1[,18]>5,"+", "-"), main="U=0.9 O=0.2",ylim=c(0,400))
plot(jitter(IS2[,5]), jitter(IS2[,6]), col= ifelse(IS2[, 18]>5,2,3), pch=ifelse(IS2[,18]>5,"+", "-"), main="U=0.5 O=0.8",ylim=c(0,400))

@



% ====================================================================
\section{Distance Functions}\label{sec:distFunc}

In this section we briefly explain the different distance functions implemented, which can be used for calculating the neighbors of the examples along several strategies for classification or regression tasks.
The implementation of these functions was motivated by the inclusion in \UBL of several methods which depend on the nearest neighbors computation. Although several efficient tools exist for evaluating the nearest neighbors, they are mostly limited to the use of the Euclidean distance. In this context, restricting the user to the use of the Euclidean distance can be a limitation, namely because several data sets include nominal features which can and should also be considered in the neighbors computation. In fact, all the features contained in the data set, whether nominal or numeric, should be taken into account when computing the nearest neighbors. Thus, in order to avoid the restriction of computing nearest neighbors based only on the data set numeric features we have implemented several possible measures which can be used for data sets containing only nominal or numeric features or simultaneously both types. By the implementation of several distance functions, we aim at providing an increased flexibility for computing the nearest neighbors while ensuring that no feature information is wasted.

Several distance measures exist which can deal only with numeric or nominal features or can integrate both types in the distance evaluation. Distance functions such as \texttt{Canberra}, \texttt{Euclidean} or \texttt{Chebyshev} are able to deal solely with numeric attributes while the \texttt{Overlap} measure handles only nominal features. Other measures such as \texttt{HEOM} or \texttt{HVDM} try to use both types of features.

We now briefly describe the distance functions implemented in this package. We begin with the distance functions suitable for data sets with only numeric features. Let us suppose $x$ and $y$ are two examples of a data set with m features. The well-known Euclidean distance can be computed as shown in Equation \ref{eq:Eucl}. The Manhattan distance, also known as city-block distance or taxicab metric, may be calculated with Equation \ref{eq:Manhat}. 

\begin{equation}\label{eq:Eucl}
D(x,y)=\sqrt{ \sum_{i=1}^{m}(x_i-y_i)^2 }
\end{equation}

\begin{equation}\label{eq:Manhat}
D(x,y)=\sum_{i=1}^{m}|x_i-y_i|
\end{equation}
A generalization of these distance functions is obtained with the Minkowsky distance (cf. Equation \ref{eq:Minkowsky}). In this case, by setting $r$ to 1 or 2 we can obtain respectively the Manhattan and Euclidean distance functions.
\begin{equation}\label{eq:Minkowsky}
D(x,y)=\left( \sum_{i=1}^{m}|x_i-y_i|^r\right) ^{\frac{1}{r}}
\end{equation}

The Canberra distance, defined in Equation \ref{eq:Canberra}, and the Chebyshev distance (Equation \ref{eq:Chebychev}) are also functions which can be applied to evaluate the distance between examples described only by numeric features.



\begin{equation}\label{eq:Canberra}
D(x,y)= \sum_{i=1}^{m}\frac{|x_i-y_i|}{|x_i|+|y_i|}
\end{equation}

\begin{equation}\label{eq:Chebychev}
D(x,y)=\max_{i=1}^{m}|x_i-y_i|
\end{equation}

All the previous distance functions can be used in \UBL for computing the nearest neighbors. After selecting an appropriate approach to apply on a data set, it is only necessary to set the parameter \texttt{dist} of the approach to the desired distance function and the \texttt{p} parameter if it is a Minkowsky distance. We illustrate this in the next example.


<<numeric_measures_ex>>=
data <- iris[-c(91:125),]
# using the default of smote to invert the frequencies of the data set
set.seed(123)
sm.Eu <- smoteClassif(Species~., data, dist="Euclidean", 
                      C.perc="extreme", k=3)
set.seed(123)
sm.Man1 <- smoteClassif(Species~., data, dist="Manhattan",
                        C.perc="extreme", k=3)
set.seed(123)
sm.Man2 <- smoteClassif(Species~., data, dist="p-norm", p=1,
                        C.perc="extreme", k=3)
set.seed(123)
sm.5norm <- smoteClassif(Species~., data, dist="p-norm", p=5, 
                         C.perc="extreme", k=3)
set.seed(123)
sm.Cheb <- smoteClassif(Species~., data, dist="Chebyshev", 
                        C.perc="extreme", k=3)
set.seed(123)
sm.Canb <- smoteClassif(Species~., data, dist="Canberra", 
                        C.perc="extreme", k=3)
@

The impact of using these distance functions with smote strategy can be visualized in Figure \ref{fig:dist_num}.


<<dist_num, fig.cap="Impact of using different distance functions with smote strategy.", echo=FALSE>>=
par(mfrow=c(3,2))
plot(data[,1], data[,2], pch=as.integer(data[,5]), col=as.integer(data[,5]), xlim=c(4,8), ylim=c(2,4.5), main="Original data")
plot(sm.Eu[,1], sm.Eu[,2], pch=as.integer(sm.Eu[,5]), col=as.integer(sm.Eu[,5]), xlim=c(4,8), ylim=c(2,4.5), main="Euclidean distance")
plot(sm.Man1[,1], sm.Man1[,2], pch=as.integer(sm.Man1[,5]), col=as.integer(sm.Man1[,5]), xlim=c(4,8), ylim=c(2,4.5), main="Manhattan distance")
plot(sm.5norm[,1], sm.5norm[,2], pch=as.integer(sm.5norm[,5]), col=as.integer(sm.5norm[,5]), xlim=c(4,8), ylim=c(2,4.5), main="Minkowsky with r=5")
plot(sm.Cheb[,1], sm.Cheb[,2], pch=as.integer(sm.Cheb[,5]), col=as.integer(sm.Cheb[,5]), xlim=c(4,8), ylim=c(2,4.5), main="Chebyshev distance")
plot(sm.Canb[,1], sm.Canb[,2], pch=as.integer(sm.Canb[,5]), col=as.integer(sm.Canb[,5]), xlim=c(4,8), ylim=c(2,4.5), main="Canberra distance")


@

All the previously described metrics do not perform any type of normalization. This step, if wanted, should be performed previously by the user.


Regarding nominal attributes, a distance function which is suitable for handling this type of variables is the overlap measure, which is defined in Equation \ref{eq:overlap}.


\begin{equation}\label{eq:overlap}
overlap(x,y) = \begin{cases} 1 &\mbox{if } x \neq y \\
0 & \mbox{if } x = y. \end{cases} 
\end{equation}

This distance function can be used in strategies that require the computation of nearest neighbors as follows:

<<overlap_ex>>=
# build a data set with all nominal features
library(DMwR)
data(algae)
clean.algae <- algae[complete.cases(algae),1:3]

# speed is considered the target class
summary(clean.algae)
ndat1 <- ENNClassif(speed~., clean.algae, dist="Overlap",  Cl=c("high", "medium"))
ndat2 <- ENNClassif(speed~., clean.algae, dist="Overlap",  Cl="all")

#all the smaller classes are the most important
ndat3 <- NCLClassif(speed~., clean.algae, dist="Overlap",  Cl="smaller")
# the most important classes are "high" and "low"
ndat4 <- NCLClassif(speed~., clean.algae, dist="Overlap",  Cl=c("high", "low"))

ndat5 <- smoteClassif(speed~., clean.algae, dist="Overlap", C.perc="balance")
@

Figure \ref{fig:dist_overlap} shows the impact of using the overlap distance function, with several different strategies, on a data set consisting of only nominal variables.
<<dist_overlap, fig.cap="Using Overlap distance function with different strategies on a data set with only nominal features.", echo=FALSE>>=
g1 <- ggplot(clean.algae, aes(x = speed, fill=size))+ geom_bar()+ggtitle("Original data")

g2 <- ggplot(ndat2[[1]], aes(x = speed, fill=size))+ geom_bar()+ggtitle("ENN strategy")

g3 <- ggplot(ndat3, aes(x = speed, fill=size))+ geom_bar()+ggtitle("NCL strategy")

g4 <- ggplot(ndat5, aes(x = speed, fill=size))+ geom_bar()+ggtitle("smote strategy")

plots <- list(g1, g2, g3, g4)

do.call(grid.arrange, plots)
@

To evaluate the distance between examples described by nominal and numeric variables a simple adaptation of the previous distance functions can be performed. The Heterogeneous Euclidean-Overlap Metric function (HEOM) is a popular solution for these situations. Equations \ref{eq:HEOM} and \ref{eq:auxHEOM} describe how this distance is computed.


\begin{equation}\label{eq:HEOM}
HEOM(x,y)= \sqrt{\sum_{a=1}^{m}d_a^2(x_a,y_a) }
\end{equation}


\begin{equation}\label{eq:auxHEOM}
\mbox{where  } d_a(x,y)= \begin{cases} 1 & \mbox{if } x \vee y \mbox{ are unknown, else} \\
overlap(x,y) & \mbox{if } a \mbox{ is nominal, else} \\
\frac{|x-y|}{range_a}
\end{cases}
\end{equation}
\noindent where $range_a=max_a-min_a$


<<HEOM_ex>>=
# build a data set with nominal and numeric features
library(DMwR)
data(algae)
clean.algae <- algae[complete.cases(algae),1:5]

# speed is the target class
summary(clean.algae)
enn <- ENNClassif(speed~., clean.algae, dist="HEOM",  Cl="all", k=5)[[1]]
#consider all the smaller classes as the most important
ncl <- NCLClassif(speed~., clean.algae, dist="HEOM",  Cl="smaller")
sm <- smoteClassif(speed~., clean.algae, dist="HEOM", C.perc="balance")
@


In Figure \ref{fig:dist_heom} we can observe the impact of using the HEOM distance function with several strategies.
<<dist_heom, fig.cap="Using HEOM distance function with different strategies on a data set with both nominal and numeric features.", echo=FALSE>>=
par(mfrow = c(2, 2))
plot(clean.algae$mxPH, clean.algae$mnO2,pch=as.integer(clean.algae$speed), col=as.integer(clean.algae$speed), xlim=c(7,9.5), ylim=c(1.5,13.5), main="original data")
plot(enn$mxPH, enn$mnO2,pch=as.integer(enn$speed), col=as.integer(enn$speed), xlim=c(7,9.5), ylim=c(1.5,13.5), main="ENN strategy applied")
plot(ncl$mxPH, ncl$mnO2,pch=as.integer(ncl$speed), col=as.integer(ncl$speed), xlim=c(7,9.5), ylim=c(1.5,13.5), main="NCL strategy applied")
plot(sm$mxPH, sm$mnO2,pch=as.integer(sm$speed), col=as.integer(sm$speed), xlim=c(7,9.5), ylim=c(1.5,13.5), main="smote strategy applied")
@


Other proposals, such as the Heterogeneous Value Difference Metric (HVDM), were tested for handling both nominal and numeric features. The HVDM uses the notion of Value Distance Metric (VDM) which was introduced by \cite{stanfill1986toward} to address the distance computation with nominal variables. The VDM metric is described in Equation \ref{eq:VDM}.

\begin{equation}\label{eq:VDM}
VDM_a(x,y)= \sum_{c=1}^{C}  \left\lvert \frac{N_{a,x,c}}{N_{a,x}}-\frac{N_{a,y,c}}{N_{a,y}}\right\rvert ^q
\end{equation}
where, \\
$a$ is the nominal attribute under consideration;\\
$C$ is the number of classes existing on the data set;\\
$q$ is a constant;\\
$N_{a,x,c}$ represents the number of examples which have value $x$ for the feature $a$ and class label $c$;\\
$N_{a,x}$ is the number of examples that have value $x$ for the feature $a$.\\


The HVDM distance function was proposed by \cite{wilson1997improved} and its definition, presented in Equations \ref{eq:HVDM}and \ref{eq:auxHVDM}, is similar to the HEOM.

\begin{equation}\label{eq:HVDM}
HVDM(x,y)= \sqrt{\sum_{a=1}^{m}d_a^2(x_a,y_a) }
\end{equation}

\begin{equation}\label{eq:auxHVDM}
\mbox{where  } d_a(x,y)= \begin{cases} 1 & \mbox{if } x \vee y \mbox{ are unknown, otherwise} \\
norm-vdm_a(x,y) & \mbox{if } a \mbox{ is nominal} \\
norm-diff_a(x,y) & \mbox{if } a \mbox{ is numeric} \\
\end{cases}
\end{equation}

The HVDM distance function uses a normalized version of the absolute value of the difference between two examples for the numeric attributes (Equation \ref{eq:HVDMnum}) and uses for the nominal attributes an also normalized version of the VDM measure for the nominal attributes (Equation \ref{eq:HVDMnom}) .

\begin{equation}\label{eq:HVDMnom}
norm-vdm_a(x,y)=\sqrt{VDM_a(x,y)}=\sqrt{\sum_{c=1}^{C}  \left\lvert \frac{N_{a,x,c}}{N_{a,x}}-\frac{N_{a,y,c}}{N_{a,y}}\right\rvert ^2}
\end{equation}


\begin{equation}\label{eq:HVDMnum}
norm-diff_a(x,y)= \frac{|x-y|}{4\sigma_a}
\end{equation}


Regarding Equation \ref{eq:HVDMnom}, several normalization of the VDM measure were proposed and tested in \cite{wilson1997improved}. The version presented here and implemented in \UBL was the one that achieved the best performance. We also highlight that the distance function proposed for the numeric attributes uses a different normalization which relies on the standard deviation of of each attribute $\sigma_a$.


The HVDM distance can be used simply by setting the \texttt{dist} parameter to "HVDM". Although it is a function suitable for both nominal and numeric, if the data set provided contains only one type of attributes only the corresponding distance will be used.



<<HVDM_ex>>=
# build a data set with both nominal and numeric features
library(DMwR)
data(algae)
clean.algae <- algae[complete.cases(algae),c(1:6)]

# speed is considered the target class
summary(clean.algae)

dat1 <- smoteClassif(speed~., clean.algae, dist="HVDM", C.perc="extreme")

dat2 <- NCLClassif(speed~., clean.algae, k=3, dist="HVDM", Cl="smaller")

dat3 <- TomekClassif(speed~., clean.algae, dist="HVDM", Cl="all", rem="both")
@

Figure \ref{fig:dist_HVDM} shows the result of applying HVDM distance function for several different strategies, on a data set consisting of numeric and nominal features.
<<dist_HVDM, fig.cap="Using HVDM distance function with different strategies.", echo=FALSE>>=
g1 <- ggplot(clean.algae, aes(x = mxPH, y=mnO2, col=speed))+ geom_point()+ggtitle("Original data")

g2 <- ggplot(dat1, aes(x = mxPH, y=mnO2, col=speed))+ geom_point()+ggtitle("smote'd data")

g3 <- ggplot(dat2, aes(x = mxPH, y=mnO2, col=speed))+ geom_point()+ggtitle("NCL strategy")

g4 <- ggplot(dat3[[1]], aes(x = mxPH, y=mnO2, col=speed))+ geom_point()+ggtitle("Tomek links strategy")

plots <- list(g1, g2, g3, g4)

do.call(grid.arrange, plots)
@


In Figure \ref{fig:dist_HVDM2} the impact of smote strategy applied with different distance functions on a data set can be observed.

<<dist_HVDM2, fig.cap="Using different distance functions with  smote strategy.", echo=FALSE>>=
set.seed(123)
d1 <- smoteClassif(speed~., clean.algae, dist="HVDM", C.perc="extreme")
set.seed(123)
d2 <- smoteClassif(speed~., clean.algae, dist="HEOM", C.perc="extreme")

# in order to use metrics for numeric attributes only we must remove the nominal attributes
set.seed(123)
d3 <- smoteClassif(speed~., clean.algae[,3:6], dist="Euclidean", C.perc="extreme")
set.seed(123)
d4 <- smoteClassif(speed~., clean.algae[,3:6], dist="Chebyshev", C.perc="extreme")
set.seed(123)
d5 <- smoteClassif(speed~., clean.algae[,3:6], dist="Manhattan", C.perc="extreme")


g1 <- ggplot(clean.algae, aes(x = mxPH, y=mnO2, col=speed))+ geom_point()+ggtitle("Original data")

g2 <- ggplot(d1, aes(x = mxPH, y=mnO2, col=speed))+ geom_point()+ggtitle("HVDM distance")

g3 <- ggplot(d2, aes(x = mxPH, y=mnO2, col=speed))+ geom_point()+ggtitle("HEOM distance")

g4 <- ggplot(d3, aes(x = mxPH, y=mnO2, col=speed))+ geom_point()+ggtitle("Euclidean")

g5 <- ggplot(d4, aes(x = mxPH, y=mnO2, col=speed))+ geom_point()+ggtitle("Chebyshev distance")

g6 <- ggplot(d5, aes(x = mxPH, y=mnO2, col=speed))+ geom_point()+ggtitle("Manhattan distance")


plots <- list(g1, g2, g3, g4, g5, g6)

do.call(grid.arrange, plots)
@




% ====================================================================
\section{Experimental Comparison of Methods for Classification Tasks}

In this Section we present some results of the experimental comparison of the implemented methods for classification tasks. 
The experiences were made with data sets with a binary target class. The main characteristics of the used data sets are described in Table \ref{tab:ClassDataBinary}.
The used learning algorithms, their parameters variants an the corresponding R packages are described in Table \ref{tab:Sys}.

We tested 8 learning variants (4 random Forest and 4 svm) on 3 data sets with 29 strategies variants (the original data, 2 random undersampling, 2 random oversampling, 2 CNN, 4 Tomek links, 4 OSS, 2 ENN, 2 NCL, 6 Gaussian Noise and 4 smote).

\begin{table}[!tbp]
\begin{center}
\resizebox{0.7\textwidth}{!}{
\begin{tabular}{crrrrr}
\hline\hline
Data Set & N & Pnom & Pnum & nRare & \%Rare\tabularnewline
\hline
Ionosphere &351 &1&32&126&0.359\tabularnewline

thor &470& 13& 3& 70&0.149\tabularnewline

Pima&768&0&8&268&0.349\tabularnewline
\hline
\hline
\end{tabular}
}
\end{center}
\caption{Classification Data sets and characteristics(N: nr. of examples; Pnom: nr. of nominal predictors; Pnum: nr. of numeric predictors; nRare: nr. of examples in the rare class; \%Rare: nRare/N).}
\label{tab:ClassDataBinary}
\end{table}

\begin{table}[!tbp]
\begin{center}
\resizebox{\textwidth}{!} {
\begin{tabular}{lll}
\hline \hline
Learner & Parameter Variants & R package \\ 
\hline 
SVM & $cost=\{10,150\},gamma=\{0.01,0.001\}$ & \textbf{e1071}~\cite{e1071} \\ 
Random Forest & $mtry=\{4,6\},ntree=\{500,750\}$ & \textbf{randomForest}~\cite{rf} \\ 
\hline \hline
\end{tabular} 
}
\end{center}
\caption{Learning algorithms and parameter variants, and the respective R packages.}\label{tab:Sys}
\end{table}


Regarding the results obtained, we can observe the workflows that achieved the best scores for each metric and data set:
<<load_res1,echo=FALSE>>=

load("allResults2Class.Rdata")
@


<<res2class, warning=FALSE, echo=FALSE>>=
topPerformers(subset(res, workflows=glob2rx('*svm*|*random*')), maxs=rep(TRUE,dim(res[[1]][[1]]@iterationsScores)[2]))
@

We can also observe which were the top performing workflows for each data set considered and each computed metric:
<<ionosphereRank, echo=FALSE>>=
rankWorkflows(subset(res, tasks='Ionosphere', workflows=glob2rx('*svm*|*random*')), maxs=rep(TRUE,dim(res[[1]][[1]]@iterationsScores)[2]))
@

We can also visualize the results. However, since the results correspond to a very large set of experiences we only visualize some subsets of the experiences. So, we can observe some results for data set Ionosphere in Figure \ref{fig:Ionosphere_plot1}.

<<Ionosphere_plot1,echo=FALSE, fig.cap="Results of Ionosphere data for strategies Gaussian Noise and smote on variants of svm learner">>=
plot(subset(res, tasks='Ionosphere', workflows=glob2rx('*none.svm*|*GN.svm*|*smote.svm*'), metrics=glob2rx('F$')))

#metricsSummary(subset(res, workflows=glob2rx('*svm*'), tasks='Ionosphere'),summary='median')
@

Using package \texttt{performanceEstimation}, a summary of Ionosphere data set results for the svm learners can also be obtained for the $F$ measure, as follows:
<<summ_Ionosphere_F,  eval=FALSE >>=
summary(subset(res, tasks='Ionosphere', 
                    workflows=glob2rx('*svm*'),
                    metrics=glob2rx('F$')))
@
We do not present these results here due to its excessive length.

The results of thor data set for the svm learning variants and the $F$ measure, are displayed in Figure \ref{fig:thor_plot1}. Here it is clear that the existing methods for dealing with imbalanced domains do not always work for all the data sets. However, we must also highlight that this was a very restrict set of experiences, and some of the resampling approaches variants not tested could have a different impact in this data set.


<<thor_plot1, echo=FALSE,fig.cap="Results of thor data on variants of svm learner", warning=FALSE>>=
plot(subset(res, tasks='pima', workflows=glob2rx('*svm*'),metrics=glob2rx('F$')))
#plot(subset(res, tasks='thor', workflows=glob2rx('*svm*'),metrics='F', partial=FALSE))
@

Regarding the Pima data set, we can observe the workflows ranking:
<<pimaRankRes, echo=FALSE>>=
rankWorkflows(subset(res, tasks='pima', workflows=glob2rx('*svm*|*random*')), maxs=rep(TRUE,dim(res[[1]][[1]]@iterationsScores)[2]))
@

Figure \ref{fig:pima_plot1} shows some partial results obtained for Pima data set with the $F$ measure. In this case we observe that the approaches that usually are more successful (random under-sample, smote and Gaussian noise strategies), here tend to present a worst performance.
<<pima_plot1, echo=FALSE, fig.cap="Results of pima data for strategies Random under-sampling, Gaussian Noise and smote on variants of svm learner">>=
plot(subset(res, tasks='pima',workflows=glob2rx('*none.svm|RU.svm|smote.svm|GN.svm*'), metrics=glob2rx('F$')))
#summary(subset(res, tasks='pima', workflows=glob2rx('*earth*'),metrics='F'))

#metricsSummary(subset(res, workflows=glob2rx('*svm*'), tasks='pima'),summary='median')

@

However, we can also observe in Figure \ref{fig:pima_plot2} that for this data set, the Tomek links and ENN strategies present an improved median performance when compared to using the original data set.  
<<pima_plot2, fig.cap="Results of pima data set for random Forest variants on original data set and data with ENN and Tomek links strategies applied.",echo=FALSE>>=
plot(subset(res, tasks='pima',workflows=glob2rx('*none.random|Tomek.random|ENN.random*'), metrics=glob2rx('F$')))

@

% ====================================================================
\section{Experimental Comparison of Methods for Regression Tasks}

In this Section we present some results of the experimental comparison of the implemented methods for regression tasks. 
The experiences were made with the data sets described in Table \ref{tab:RegressData}. The values in this Table were calculated for a relevance function automatically estimated using \texttt{uba} package and a relevance threshold of $0.8$.

\begin{table}[!tbp]
\begin{center}
\resizebox{0.9\textwidth}{!}{
\begin{tabular}{crrrrrrr}
\hline\hline
Data Set &tgt& N & Pnom & Pnum & nRare & \%Rare & Nrel bump\tabularnewline
\hline
algae &a1&198 &3&8&28&0.141& 1\tabularnewline

acceleration& acceleration& 1732& 3&11&89&0.051& 1\tabularnewline

boston& HousValue& 506& 0&14&65&0.128 & 1\tabularnewline
\hline
\hline
\end{tabular}
}
\end{center}
\caption{Regression Data sets and characteristics evaluated for a relevance function automatically determined with \texttt{uba} package and a relevance threshold of 0.8 (tgt: name of target variable; N: nr. of examples; Pnom: nr. of nominal predictors; Pnum: nr. of numeric predictors; nRare: nr. of examples in the rare class; \%Rare: nRare/N; Nrel bump: nr. of relevant bumps automatically determined).}
\label{tab:RegressData}
\end{table}


The used learning algorithms, their parameters variants an the corresponding R packages are described in Table \ref{tab:Sys2}. We tested three data sets with 18 learning algorithms variants (12 svm variants and 6 randomForest variants) and 6 types of resampling strategies. The resampling strategies tested were: "none" which represents not changing the original data set; random under-sampling (with 2 variants); random over-sampling (2 variants); Gaussian Noise (6 variants); smoteR (2 variants) and Importance Sampling (4 variants). The experiences were evaluated with the metrics available in package \texttt{uba} specially developed for this type of problems: precision, recall and F measure defined for regression tasks. In these experiences we have named precision, recall and F measure as ubaprec, ubarec and ubaF respectively.


\begin{table}[!tbp]
\begin{center}
\resizebox{\textwidth}{!} {
\begin{tabular}{lll}
\hline \hline
Learner & Parameter Variants & R package \\ 
\hline 
%MARS & $nk=\{10,17\},degree=\{1,2\},thresh=\{0.01,0.001\}$ & \textbf{earth}~\cite{earth} \\ 
SVM & $cost=\{10,150,300\},gamma=\{0.01,0.001\},epsilon=\{0.1, 0.01\}$ & \textbf{e1071}~\cite{e1071} \\ 
Random Forest & $mtry=\{5,7\},ntree=\{500,750, 1500\}$ & \textbf{randomForest}~\cite{rf} \\ 
\hline \hline
\end{tabular} 
}
\end{center}
\caption{Learning algorithms and parameter variants, and the respective R packages.}\label{tab:Sys2}
\end{table}

Regarding the results obtained, we can observe the workflows that acheived the best scores for each data set and metric:
<<load_res2,echo=FALSE>>=

load("allResultsRegress.Rdata")
@


<<resRegress, echo=FALSE>>=
topPerformers(res,maxs=rep(TRUE,dim(res[[1]][[1]]@iterationsScores)[2]))
@

We can also verify which were the best performing workflows for each tested data set and measure evaluated: 
<<rankWFRegress, echo=FALSE>>=
rankWorkflows(res,maxs=rep(TRUE,dim(res[[1]][[1]]@iterationsScores)[2]))
@


We can observe visually the performance of subsets of the best performing strategies applied for the random Forest learning variants on Figures \ref{fig:algae_plot1}, \ref{fig:acceleration_plot1} and \ref{fig:boston_plot1} regarding the data sets algae, acceleration and boston respectively.

<<algae_plot1, fig.cap="Results on algae data set for strategies none, random over-sampling and random under-sampling for random forest learning variants",echo=FALSE>>=
plot(subset(res, tasks='a1',workflows=glob2rx('*none.random|RO.rand|RU.rand*')))
@

<<acceleration_plot1, fig.cap="Results on acceleration data set for none and random over-sampling strategies with random forest learning variants",echo=FALSE>>=
plot(subset(res, tasks='acceleration',workflows=glob2rx('*none.random|RO.rand*'), metrics='F'))
@

<<boston_plot1, fig.cap="Results on boston data set for none and Importance Sampling strategy on random forest learning variants",echo=FALSE>>=
plot(subset(res, tasks='boston',workflows=glob2rx('*none.random|IS.rand*'), metrics='F'))
@


% =======================================================
\section{Conclusions}

We have presented \UBL that aims at dealing with predictive tasks under imbalanced domains. This package offers several methods for multiclass and regression problems. The approaches implemented are essentially pre-processing methods for changing the target variable distribution. This change in the data set is performed with the goal of forcing the learning algorithms to focus on the most important and less frequent cases. 

The existing strategies for dealing with imbalanced domains as a pre-processing step present the advantage of allowing the use of any standard learning algorithm without changing it. Moreover, these methods do not compromise the interpretability of the models used. As possible disadvantages we must point the difficulty of determining the ideal distribution of the domain. In fact, a perfectly balanced distribution of examples is not always the solution that provides the best results.

\newpage

\bibliographystyle{alpha}
\bibliography{UBL}
\end{document}
